<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jardim Pixel - PixiJS Otimizado</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.3.2/pixi.min.js"></script>
    <style>
        * { 
            margin: 0; 
            padding: 0; 
            box-sizing: border-box; 
        }
        
        body {
            background: #1a1a2e;
            font-family: 'Courier New', monospace;
            color: #fff;
            overflow: hidden;
            height: 100vh;
        }
        
        #pixelGarden {
            display: block;
            cursor: crosshair;
            width: 100vw;
            height: 100vh;
        }
        
        .config-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            background: rgba(74, 222, 128, 0.9);
            border: 3px solid #4ade80;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            transition: all 0.3s, opacity 0.5s;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 1000;
        }
        
        .config-btn:hover {
            background: #4ade80;
            transform: rotate(90deg) scale(1.1);
        }
        
        .panel {
            position: fixed;
            top: 0;
            right: -420px;
            width: 420px;
            height: 100vh;
            background: rgba(26, 26, 46, 0.98);
            backdrop-filter: blur(10px);
            border-left: 3px solid #4ade80;
            padding: 30px;
            overflow-y: auto;
            transition: right 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            z-index: 999;
            box-shadow: -5px 0 20px rgba(0, 0, 0, 0.5);
        }
        
        .panel.open { 
            right: 0; 
        }
        
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 15px;
            border-bottom: 2px solid #4ade80;
        }
        
        h2 {
            color: #4ade80;
            font-size: 1.8rem;
            text-shadow: 0 0 10px rgba(74, 222, 128, 0.5);
        }
        
        .close {
            background: #ef4444;
            color: white;
            border: none;
            width: 35px;
            height: 35px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 20px;
            transition: all 0.3s;
        }
        
        .close:hover {
            background: #dc2626;
            transform: rotate(90deg);
        }
        
        .section {
            margin-bottom: 25px;
        }
        
        h3 {
            color: #86efac;
            font-size: 1.1rem;
            margin-bottom: 15px;
            padding-left: 10px;
            border-left: 3px solid #4ade80;
        }
        
        .control {
            margin-bottom: 20px;
            background: rgba(30, 41, 59, 0.5);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #374151;
        }
        
        .label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            color: #d1d5db;
            font-size: 0.95rem;
        }
        
        .value {
            color: #4ade80;
            font-weight: bold;
            min-width: 60px;
            text-align: right;
        }
        
        input[type="range"] {
            width: 100%;
            height: 8px;
            -webkit-appearance: none;
            background: #374151;
            border-radius: 4px;
            outline: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: #4ade80;
            border-radius: 50%;
            cursor: pointer;
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #4ade80;
            border-radius: 50%;
            border: none;
        }
        
        .btns {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 10px;
        }
        
        button {
            background: #4ade80;
            color: #1a1a2e;
            border: none;
            padding: 12px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            font-size: 0.95rem;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        button:hover {
            background: #22c55e;
            transform: translateY(-2px);
        }
        
        .reset { 
            background: #ef4444; 
        }
        
        .reset:hover { 
            background: #dc2626; 
        }
        
        .pause { 
            background: #f59e0b; 
        }
        
        .pause:hover { 
            background: #d97706; 
        }
        
        .rain { 
            background: #3b82f6; 
        }
        
        .rain:hover { 
            background: #2563eb; 
        }
        
        .rain.active {
            background: #1e40af;
            box-shadow: 0 0 20px rgba(59, 130, 246, 0.5);
        }
        
        .stats {
            background: rgba(30, 41, 59, 0.8);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #374151;
        }
        
        .stat {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #374151;
            color: #60a5fa;
        }
        
        .stat:last-child { 
            border-bottom: none; 
        }
        
        .stat span:last-child {
            color: #4ade80;
            font-weight: bold;
        }
        
        .presets {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 8px;
        }
        
        .preset {
            padding: 8px;
            font-size: 0.85rem;
            background: rgba(74, 222, 128, 0.2);
            border: 1px solid #4ade80;
            color: #4ade80;
        }
        
        .preset:hover {
            background: rgba(74, 222, 128, 0.3);
        }
        
        .info-box {
            background: rgba(59, 130, 246, 0.1);
            border: 1px solid rgba(59, 130, 246, 0.3);
            padding: 12px;
            border-radius: 6px;
            font-size: 0.85rem;
            color: #93c5fd;
            margin-top: 10px;
        }
        
        @media (max-width: 768px) {
            .panel { 
                width: 100vw; 
                right: -100vw; 
            }
            .config-btn { 
                top: 10px; 
                right: 10px; 
                width: 45px; 
                height: 45px; 
            }
        }
        
        ::-webkit-scrollbar { 
            width: 8px; 
        }
        
        ::-webkit-scrollbar-track { 
            background: rgba(30, 41, 59, 0.5); 
        }
        
        ::-webkit-scrollbar-thumb { 
            background: #4ade80; 
            border-radius: 4px; 
        }
    </style>
</head>
<body>
    <div id="pixelGarden"></div>
    <div class="config-btn" onclick="togglePanel()">‚öôÔ∏è</div>
    
    <div class="panel" id="panel">
        <div class="header">
            <h2>‚öôÔ∏è Configura√ß√µes</h2>
            <button class="close" onclick="togglePanel()">‚úï</button>
        </div>
        
        <div class="section">
            <h3>üéÆ Controles</h3>
            <div class="btns">
                <button class="pause" id="pauseBtn" onclick="togglePause()">‚è∏ Pausar</button>
                <button class="reset" onclick="resetGarden()">üîÑ Reset</button>
                <button class="rain" id="rainBtn" onclick="toggleRain()">üåßÔ∏è Chuva</button>
            </div>
        </div>
        
        <div class="section">
            <h3>‚ö° Otimiza√ß√£o de Chunks</h3>
            <div class="control">
                <div class="label">
                    <span>Tamanho do Chunk</span>
                    <span class="value" id="val_chunkSize">16x16</span>
                </div>
                <input type="range" min="8" max="64" step="8" value="16" 
                       oninput="updateConfig('chunkSize', this.value)">
            </div>
            <div class="control">
                <div class="label">
                    <span>Chunks por Frame</span>
                    <span class="value" id="val_chunksPerFrame">4</span>
                </div>
                <input type="range" min="1" max="16" step="1" value="4" 
                       oninput="updateConfig('chunksPerFrame', this.value)">
            </div>
            <div class="info-box">
                üí° <strong>Chunks</strong> dividem o processamento em partes menores para melhor performance. Aumente se tiver FPS alto, diminua se estiver travando.
            </div>
        </div>
        
        <div class="section">
            <h3>üìê Tamanho</h3>
            <div class="control">
                <div class="label">
                    <span>Tamanho do Pixel</span>
                    <span class="value" id="val_gridSize">4px</span>
                </div>
                <input type="range" min="2" max="8" value="4" 
                       oninput="updateConfig('gridSize', this.value)">
            </div>
            <div class="control">
                <div class="label">
                    <span>Densidade</span>
                    <span class="value" id="val_density">100%</span>
                </div>
                <input type="range" min="10" max="100" step="5" value="100" 
                       oninput="updateConfig('density', this.value)">
            </div>
            <div class="control">
                <div class="label">
                    <span>Altura</span>
                    <span class="value" id="val_height">1.0x</span>
                </div>
                <input type="range" min="0.5" max="2" step="0.1" value="1" 
                       oninput="updateConfig('height', this.value)">
            </div>
        </div>
        
        <div class="section">
            <h3>üåßÔ∏è Sistema de Chuva</h3>
            <div class="control">
                <div class="label">
                    <span>Intensidade</span>
                    <span class="value" id="val_rainIntensity">50</span>
                </div>
                <input type="range" min="10" max="100" step="5" value="50" 
                       oninput="updateConfig('rainIntensity', this.value)">
            </div>
            <div class="control">
                <div class="label">
                    <span>Tamanho dos Pingos</span>
                    <span class="value" id="val_dropSize">1.0x</span>
                </div>
                <input type="range" min="0.5" max="3" step="0.1" value="1" 
                       oninput="updateConfig('dropSize', this.value)">
            </div>
            <div class="control">
                <div class="label">
                    <span>Velocidade</span>
                    <span class="value" id="val_rainSpeed">1.0x</span>
                </div>
                <input type="range" min="0.5" max="2.5" step="0.1" value="1" 
                       oninput="updateConfig('rainSpeed', this.value)">
            </div>
            <div class="control">
                <div class="label">
                    <span>Dire√ß√£o Horizontal</span>
                    <span class="value" id="val_windForce">0</span>
                </div>
                <input type="range" min="-5" max="5" step="0.5" value="0" 
                       oninput="updateConfig('windForce', this.value)">
            </div>
            <div class="control">
                <div class="label">
                    <span>For√ßa de Impacto</span>
                    <span class="value" id="val_impactForce">1.0x</span>
                </div>
                <input type="range" min="0.5" max="3" step="0.1" value="1" 
                       oninput="updateConfig('impactForce', this.value)">
            </div>
            <div class="control">
                <div class="label">
                    <span>Respingos</span>
                    <span class="value" id="val_splashAmount">5</span>
                </div>
                <input type="range" min="0" max="10" step="1" value="5" 
                       oninput="updateConfig('splashAmount', this.value)">
            </div>
        </div>
        
        <div class="section">
            <h3>‚ö° Performance</h3>
            <div class="control">
                <div class="label">
                    <span>Velocidade Global</span>
                    <span class="value" id="val_speed">1.0x</span>
                </div>
                <input type="range" min="0.1" max="3" step="0.1" value="1" 
                       oninput="updateConfig('speed', this.value)">
            </div>
            <div class="control">
                <div class="label">
                    <span>Part√≠culas de Fundo</span>
                    <span class="value" id="val_particles">100</span>
                </div>
                <input type="range" min="0" max="300" step="10" value="100" 
                       oninput="updateConfig('particles', this.value)">
            </div>
            <div class="control">
                <div class="label">
                    <span>Max Vagalumes</span>
                    <span class="value" id="val_maxFireflies">200</span>
                </div>
                <input type="range" min="50" max="500" step="25" value="200" 
                       oninput="updateConfig('maxFireflies', this.value)">
            </div>
        </div>
        
        <div class="section">
            <h3>üéØ Presets</h3>
            <div class="presets">
                <button class="preset" onclick="applyPreset('low')">Baixo</button>
                <button class="preset" onclick="applyPreset('medium')">M√©dio</button>
                <button class="preset" onclick="applyPreset('high')">Alto</button>
                <button class="preset" onclick="applyPreset('ultra')">Ultra</button>
                <button class="preset" onclick="applyPreset('retro')">Retro</button>
                <button class="preset" onclick="applyPreset('storm')">‚õàÔ∏è Tempestade</button>
            </div>
        </div>
        
        <div class="section">
            <h3>üìä Estat√≠sticas</h3>
            <div class="stats">
                <div class="stat">
                    <span>üå± Grama Ativa</span>
                    <span id="stat_grass">0</span>
                </div>
                <div class="stat">
                    <span>üå∏ Flores</span>
                    <span id="stat_flowers">0</span>
                </div>
                <div class="stat">
                    <span>‚ú® Vagalumes</span>
                    <span id="stat_fireflies">0</span>
                </div>
                <div class="stat">
                    <span>üíß Gotas de Chuva</span>
                    <span id="stat_rain">0</span>
                </div>
                <div class="stat">
                    <span>üí¶ Respingos</span>
                    <span id="stat_splashes">0</span>
                </div>
                <div class="stat">
                    <span>üì¶ Total de Chunks</span>
                    <span id="stat_chunks">0</span>
                </div>
                <div class="stat">
                    <span>‚ö° FPS</span>
                    <span id="stat_fps">60</span>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        const app = new PIXI.Application({
            background: '#2a1810',
            resizeTo: window,
            antialias: false,
            resolution: 1
        });
        
        document.getElementById('pixelGarden').appendChild(app.view);
        
        const backgroundContainer = new PIXI.Container();
        const grassContainer = new PIXI.Container();
        const flowerContainer = new PIXI.Container();
        const fireflyContainer = new PIXI.ParticleContainer(500, {
            scale: true,
            position: true,
            rotation: false,
            tint: true,
            alpha: true
        });
        const rainContainer = new PIXI.ParticleContainer(1000, {
            scale: true,
            position: true,
            rotation: true,
            tint: false,
            alpha: true
        });
        const splashContainer = new PIXI.ParticleContainer(500, {
            scale: true,
            position: true,
            rotation: false,
            tint: false,
            alpha: true
        });
        
        app.stage.addChild(backgroundContainer);
        app.stage.addChild(grassContainer);
        app.stage.addChild(flowerContainer);
        app.stage.addChild(fireflyContainer);
        app.stage.addChild(rainContainer);
        app.stage.addChild(splashContainer);
        
        const config = {
            gridSize: 4,
            density: 100,
            height: 1,
            speed: 1,
            particles: 100,
            maxFireflies: 200,
            chunkSize: 16,
            chunksPerFrame: 4,
            rainIntensity: 50,
            dropSize: 1,
            rainSpeed: 1,
            windForce: 0,
            impactForce: 1,
            splashAmount: 5
        };
        
        const state = {
            cols: 0,
            rows: 0,
            grass: [],
            flowers: [],
            fireflies: [],
            raindrops: [],
            splashes: [],
            impacts: [],
            fireflyPool: [],
            raindropPool: [],
            splashPool: [],
            chunks: [],
            chunkCols: 0,
            chunkRows: 0,
            currentChunkIndex: 0,
            isGrowing: true,
            isRaining: false,
            mouseX: -100,
            mouseY: -100,
            isMouseDown: false,
            time: 0,
            fps: 60,
            lastTime: performance.now(),
            frames: 0,
            fpsTime: 0,
            uiVisible: true,
            lastMouseMove: Date.now()
        };
        
        const GRASS_COLORS = [
            [26, 77, 46],
            [45, 90, 61],
            [61, 107, 74],
            [77, 124, 91],
            [93, 141, 108],
            [109, 158, 125],
            [125, 175, 142]
        ];
        
        const FLOWER_COLORS = [
            [255, 68, 68],
            [255, 107, 107],
            [255, 170, 68],
            [255, 221, 68],
            [255, 68, 170],
            [170, 68, 255],
            [68, 68, 255]
        ];
        
        const sinCache = new Float32Array(360);
        const cosCache = new Float32Array(360);
        
        for (let i = 0; i < 360; i++) {
            const radians = (i * Math.PI) / 180;
            sinCache[i] = Math.sin(radians);
            cosCache[i] = Math.cos(radians);
        }
        
        function fastSin(angle) {
            const normalized = ((angle % (Math.PI * 2)) / (Math.PI * 2)) * 360;
            return sinCache[Math.floor(normalized) % 360];
        }
        
        function fastCos(angle) {
            const normalized = ((angle % (Math.PI * 2)) / (Math.PI * 2)) * 360;
            return cosCache[Math.floor(normalized) % 360];
        }
        
        function rgbToHex(r, g, b) {
            return (r << 16) | (g << 8) | b;
        }
        
        let grassTextures = [];
        let raindropTexture = null;
        let fireflyTexture = null;
        let splashTexture = null;
        let backgroundParticles = null;
        
        function createGrassTextures(gridSize) {
            const textures = [];
            const maxHeight = 64;
            
            for (let colorIdx = 0; colorIdx < GRASS_COLORS.length; colorIdx++) {
                const canvas = document.createElement('canvas');
                canvas.width = gridSize;
                canvas.height = maxHeight;
                const ctx = canvas.getContext('2d');
                
                for (let h = 0; h < maxHeight; h++) {
                    const progress = h / maxHeight;
                    const blendedColorIdx = Math.min(
                        Math.floor(progress * GRASS_COLORS.length),
                        GRASS_COLORS.length - 1
                    );
                    
                    const [r, g, b] = GRASS_COLORS[blendedColorIdx];
                    ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                    ctx.fillRect(0, maxHeight - h - 1, gridSize, 1);
                }
                
                textures.push(PIXI.Texture.from(canvas));
            }
            
            return textures;
        }
        
        function createRaindropTexture(width, height) {
            const graphics = new PIXI.Graphics();
            graphics.beginFill(0x96c8ff);
            graphics.drawRect(0, 0, width, height);
            graphics.endFill();
            return app.renderer.generateTexture(graphics);
        }
        
        function createFireflyTexture(size) {
            const graphics = new PIXI.Graphics();
            graphics.beginFill(0x66ccff);
            graphics.drawRect(0, 0, size, size);
            graphics.endFill();
            return app.renderer.generateTexture(graphics);
        }
        
        function createSplashTexture(size) {
            const graphics = new PIXI.Graphics();
            graphics.beginFill(0x96c8ff);
            graphics.drawRect(0, 0, size, size);
            graphics.endFill();
            return app.renderer.generateTexture(graphics);
        }
        
        function createBackgroundParticles() {
            const graphics = new PIXI.Graphics();
            graphics.beginFill(0x3c281e, 0.15);
            for (let i = 0; i < config.particles; i++) {
                const x = (Math.random() * app.screen.width) | 0;
                const y = (Math.random() * app.screen.height) | 0;
                graphics.drawRect(x, y, 2, 2);
            }
            graphics.endFill();
            return graphics;
        }
        
        class Chunk {
            constructor(x, y, size) {
                this.x = x;
                this.y = y;
                this.size = size;
                this.startCol = x * size;
                this.startRow = y * size;
                this.endCol = Math.min(this.startCol + size, state.cols);
                this.endRow = Math.min(this.startRow + size, state.rows);
            }
        }
        
        function initializeChunks() {
            state.chunkCols = Math.ceil(state.cols / config.chunkSize);
            state.chunkRows = Math.ceil(state.rows / config.chunkSize);
            state.chunks = [];
            state.currentChunkIndex = 0;
            
            for (let cy = 0; cy < state.chunkRows; cy++) {
                for (let cx = 0; cx < state.chunkCols; cx++) {
                    state.chunks.push(new Chunk(cx, cy, config.chunkSize));
                }
            }
        }
        
        function initializeGarden() {
            state.cols = Math.floor(app.screen.width / config.gridSize);
            state.rows = Math.floor(app.screen.height / config.gridSize);
            state.grass = new Array(state.cols);
            
            grassContainer.removeChildren();
            flowerContainer.removeChildren();
            fireflyContainer.removeChildren();
            rainContainer.removeChildren();
            splashContainer.removeChildren();
            backgroundContainer.removeChildren();
            
            grassTextures = createGrassTextures(config.gridSize);
            raindropTexture = createRaindropTexture(2, 10);
            fireflyTexture = createFireflyTexture(3);
            splashTexture = createSplashTexture(2);
            
            if (config.particles > 0) {
                backgroundParticles = createBackgroundParticles();
                backgroundContainer.addChild(backgroundParticles);
            }
            
            let activeCount = 0;
            for (let x = 0; x < state.cols; x++) {
                state.grass[x] = new Array(state.rows);
                for (let y = 0; y < state.rows; y++) {
                    const isActive = Math.random() * 100 < config.density;
                    
                    const cell = {
                        height: isActive ? Math.random() * 3 : 0,
                        maxHeight: isActive ? (8 + Math.random() * 12) * config.height : 0,
                        growthRate: 0.02 + Math.random() * 0.03,
                        colorIndex: Math.floor(Math.random() * GRASS_COLORS.length),
                        offset: Math.random() * Math.PI * 2,
                        swaySpeed: 0.02 + Math.random() * 0.03,
                        sway: 0,
                        swayDecay: 0.92 + Math.random() * 0.06,
                        active: isActive,
                        wetness: 0,
                        impactSway: 0,
                        impactDecay: 0.85,
                        sprite: null
                    };
                    
                    if (isActive) {
                        const sprite = new PIXI.Sprite(grassTextures[cell.colorIndex]);
                        sprite.anchor.set(0.5, 1);
                        sprite.x = x * config.gridSize + config.gridSize / 2;
                        sprite.y = y * config.gridSize;
                        sprite.height = 0;
                        grassContainer.addChild(sprite);
                        cell.sprite = sprite;
                        activeCount++;
                    }
                    
                    state.grass[x][y] = cell;
                }
            }
            
            state.flowers = [];
            state.fireflies = [];
            state.raindrops = [];
            state.splashes = [];
            state.impacts = [];
            
            initializeChunks();
        }
        
        function getFirefly() {
            if (state.fireflyPool.length > 0) {
                return state.fireflyPool.pop();
            }
            return {
                x: 0, y: 0, vx: 0, vy: 0,
                size: 0, alpha: 0, pulseSpeed: 0, life: 0,
                trail: [],
                sprite: new PIXI.Sprite(fireflyTexture)
            };
        }
        
        function releaseFirefly(firefly) {
            if (firefly.sprite) {
                firefly.sprite.visible = false;
            }
            if (state.fireflyPool.length < config.maxFireflies) {
                state.fireflyPool.push(firefly);
            }
        }
        
        function getRaindrop() {
            if (state.raindropPool.length > 0) {
                return state.raindropPool.pop();
            }
            return {
                x: 0, y: 0, vx: 0, vy: 0,
                length: 0, width: 0, alpha: 0, hasHit: false,
                sprite: new PIXI.Sprite(raindropTexture)
            };
        }
        
        function releaseRaindrop(drop) {
            if (drop.sprite) {
                drop.sprite.visible = false;
            }
            if (state.raindropPool.length < 1000) {
                state.raindropPool.push(drop);
            }
        }
        
        function getSplash() {
            if (state.splashPool.length > 0) {
                return state.splashPool.pop();
            }
            return {
                x: 0, y: 0, vx: 0, vy: 0,
                size: 0, alpha: 0, life: 0, gravity: 0,
                sprite: new PIXI.Sprite(splashTexture)
            };
        }
        
        function releaseSplash(splash) {
            if (splash.sprite) {
                splash.sprite.visible = false;
            }
            if (state.splashPool.length < 500) {
                state.splashPool.push(splash);
            }
        }
        
        function createFirefly() {
            if (state.fireflies.length >= config.maxFireflies) return;
            
            const angle = Math.random() * Math.PI * 2;
            const speed = 1 + Math.random() * 2;
            const firefly = getFirefly();
            
            firefly.x = state.mouseX + (Math.random() - 0.5) * 20;
            firefly.y = state.mouseY + (Math.random() - 0.5) * 20;
            firefly.vx = Math.cos(angle) * speed;
            firefly.vy = Math.sin(angle) * speed;
            firefly.size = 1 + Math.random() * 2;
            firefly.alpha = 0.7 + Math.random() * 0.3;
            firefly.pulseSpeed = 3 + Math.random() * 4;
            firefly.life = 100 + Math.random() * 50;
            firefly.trail = [];
            
            firefly.sprite.visible = true;
            firefly.sprite.anchor.set(0.5);
            firefly.sprite.scale.set(firefly.size);
            fireflyContainer.addChild(firefly.sprite);
            
            state.fireflies.push(firefly);
        }
        
        function createFlower() {
            if (Math.random() > 0.98 && state.flowers.length < 50) {
                const flower = {
                    x: Math.random() * state.cols,
                    y: Math.random() * state.rows,
                    height: 0,
                    maxHeight: (15 + Math.random() * 10) * config.height,
                    growthRate: 0.05 + Math.random() * 0.05,
                    colorIndex: Math.floor(Math.random() * FLOWER_COLORS.length),
                    petalSize: 2 + Math.random() * 2,
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.02,
                    graphics: new PIXI.Graphics()
                };
                
                flowerContainer.addChild(flower.graphics);
                state.flowers.push(flower);
            }
        }
        
        function createRaindrop() {
            if (!state.isRaining) return;
            
            const baseLength = 8 + Math.random() * 8;
            const drop = getRaindrop();
            
            drop.x = Math.random() * app.screen.width;
            drop.y = -5;
            drop.vx = config.windForce * 0.5;
            drop.vy = (8 + Math.random() * 4) * config.rainSpeed;
            drop.length = baseLength * config.dropSize;
            drop.width = Math.max(1, config.dropSize);
            drop.alpha = 0.3 + Math.random() * 0.3;
            drop.hasHit = false;
            
            drop.sprite.visible = true;
            drop.sprite.anchor.set(0.5, 1);
            drop.sprite.alpha = drop.alpha;
            drop.sprite.scale.set(drop.width, drop.length);
            rainContainer.addChild(drop.sprite);
            
            state.raindrops.push(drop);
        }
        
        function createSplash(x, y) {
            const numParticles = Math.floor(config.splashAmount);
            
            for (let i = 0; i < numParticles; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 2 + Math.random() * 4;
                const splash = getSplash();
                
                splash.x = x;
                splash.y = y;
                splash.vx = Math.cos(angle) * speed;
                splash.vy = Math.sin(angle) * speed - 2;
                splash.size = 1 + Math.random() * 2;
                splash.alpha = 0.6 + Math.random() * 0.4;
                splash.life = 20 + Math.random() * 10;
                splash.gravity = 0.3;
                
                splash.sprite.visible = true;
                splash.sprite.anchor.set(0.5);
                splash.sprite.scale.set(splash.size);
                splash.sprite.alpha = splash.alpha;
                splashContainer.addChild(splash.sprite);
                
                state.splashes.push(splash);
            }
        }
        
        function createImpact(gridX, gridY, force) {
            state.impacts.push({
                gridX: gridX,
                gridY: gridY,
                radius: 3,
                force: force * config.impactForce,
                life: 15,
                maxLife: 15
            });
        }
        
        function updateChunk(chunk) {
            const mouseGridX = Math.floor(state.mouseX / config.gridSize);
            const mouseGridY = Math.floor(state.mouseY / config.gridSize);
            const interactionRadius = 5;
            const radiusSquared = interactionRadius * interactionRadius;
            
            for (let x = chunk.startCol; x < chunk.endCol; x++) {
                for (let y = chunk.startRow; y < chunk.endRow; y++) {
                    const cell = state.grass[x][y];
                    if (!cell.active) continue;
                    
                    if (state.isGrowing && cell.height < cell.maxHeight) {
                        cell.height += cell.growthRate * config.speed;
                    }
                    
                    if (cell.sway > 0.1) {
                        cell.sway *= cell.swayDecay;
                    } else {
                        cell.sway = 0;
                    }
                    
                    if (cell.impactSway > 0.1) {
                        cell.impactSway *= cell.impactDecay;
                    } else {
                        cell.impactSway = 0;
                    }
                    
                    const dx = x - mouseGridX;
                    const dy = y - mouseGridY;
                    const distanceSquared = dx * dx + dy * dy;
                    
                    if (distanceSquared <= radiusSquared) {
                        const distance = Math.sqrt(distanceSquared);
                        const influence = (1 - distance / interactionRadius) * 8;
                        cell.sway = Math.max(cell.sway, influence * 0.7);
                    }
                    
                    if (cell.wetness > 0) {
                        cell.wetness = Math.max(0, cell.wetness - 0.01 * config.speed);
                    }
                }
            }
        }
        
        function updateGrassChunked() {
            for (let i = 0; i < config.chunksPerFrame; i++) {
                const chunk = state.chunks[state.currentChunkIndex];
                updateChunk(chunk);
                state.currentChunkIndex = (state.currentChunkIndex + 1) % state.chunks.length;
            }
            
            for (const impact of state.impacts) {
                const centerX = impact.gridX;
                const centerY = impact.gridY;
                const radius = impact.radius;
                const radiusSquared = radius * radius;
                
                for (let x = Math.max(0, centerX - radius); x < Math.min(state.cols, centerX + radius + 1); x++) {
                    for (let y = Math.max(0, centerY - radius); y < Math.min(state.rows, centerY + radius + 1); y++) {
                        const cell = state.grass[x][y];
                        if (!cell.active) continue;
                        
                        const dx = x - centerX;
                        const dy = y - centerY;
                        const distanceSquared = dx * dx + dy * dy;
                        
                        if (distanceSquared <= radiusSquared) {
                            const distance = Math.sqrt(distanceSquared);
                            const influence = (1 - distance / radius) * impact.force;
                            
                            const angle = Math.atan2(dy, dx);
                            cell.impactSway += influence * Math.cos(angle) * 2;
                            cell.wetness = Math.min(1, cell.wetness + 0.3);
                        }
                    }
                }
            }
        }
        
        function updateFlowers() {
            if (state.isGrowing) createFlower();
            
            for (const flower of state.flowers) {
                if (state.isGrowing && flower.height < flower.maxHeight) {
                    flower.height += flower.growthRate * config.speed;
                }
                
                if (flower.height >= flower.maxHeight * 0.8) {
                    flower.rotation += flower.rotationSpeed;
                }
            }
        }
        
        function updateFireflies() {
            if (state.isMouseDown && Math.random() > 0.7) {
                createFirefly();
                createFirefly();
            }
            
            for (let i = state.fireflies.length - 1; i >= 0; i--) {
                const firefly = state.fireflies[i];
                
                firefly.x += firefly.vx * config.speed;
                firefly.y += firefly.vy * config.speed;
                firefly.life -= config.speed;
                
                firefly.trail.push({ x: firefly.x, y: firefly.y });
                if (firefly.trail.length > 10) firefly.trail.shift();
                
                const isOutOfBounds = firefly.x < -10 || firefly.x > app.screen.width + 10 ||
                                     firefly.y < -10 || firefly.y > app.screen.height + 10;
                
                if (firefly.life <= 0 || isOutOfBounds) {
                    releaseFirefly(firefly);
                    state.fireflies.splice(i, 1);
                }
            }
        }
        
        function updateRain() {
            if (state.isRaining && Math.random() * 100 < config.rainIntensity) {
                createRaindrop();
            }
            
            for (let i = state.raindrops.length - 1; i >= 0; i--) {
                const drop = state.raindrops[i];
                
                drop.x += drop.vx * config.speed;
                drop.y += drop.vy * config.speed;
                
                const gridX = Math.floor(drop.x / config.gridSize);
                const gridY = Math.floor(drop.y / config.gridSize);
                
                let shouldRemove = false;
                
                if (gridX >= 0 && gridX < state.cols && gridY >= 0 && gridY < state.rows) {
                    const cell = state.grass[gridX][gridY];
                    
                    if (cell && cell.active && cell.height > 0) {
                        const grassTopY = gridY * config.gridSize - cell.height;
                        
                        if (drop.y >= grassTopY && !drop.hasHit) {
                            drop.hasHit = true;
                            createSplash(drop.x, grassTopY);
                            createImpact(gridX, gridY, 3);
                            shouldRemove = true;
                        }
                    }
                }
                
                if (drop.y >= app.screen.height - 5) {
                    if (!drop.hasHit) {
                        createSplash(drop.x, app.screen.height - 5);
                        if (gridX >= 0 && gridX < state.cols) {
                            createImpact(gridX, state.rows - 1, 2);
                        }
                    }
                    shouldRemove = true;
                }
                
                if (drop.x < -20 || drop.x > app.screen.width + 20) {
                    shouldRemove = true;
                }
                
                if (shouldRemove) {
                    releaseRaindrop(drop);
                    state.raindrops.splice(i, 1);
                }
            }
        }
        
        function updateSplashes() {
            for (let i = state.splashes.length - 1; i >= 0; i--) {
                const splash = state.splashes[i];
                
                splash.x += splash.vx * config.speed;
                splash.y += splash.vy * config.speed;
                splash.vy += splash.gravity * config.speed;
                splash.life -= config.speed;
                
                if (splash.life <= 0 || splash.y > app.screen.height) {
                    releaseSplash(splash);
                    state.splashes.splice(i, 1);
                }
            }
        }
        
        function updateImpacts() {
            for (let i = state.impacts.length - 1; i >= 0; i--) {
                const impact = state.impacts[i];
                impact.life -= config.speed;
                
                if (impact.life <= 0) {
                    state.impacts.splice(i, 1);
                }
            }
        }
        
        function renderGrass() {
            let activeCount = 0;
            const mouseGridX = Math.floor(state.mouseX / config.gridSize);
            const mouseGridY = Math.floor(state.mouseY / config.gridSize);
            
            for (let x = 0; x < state.cols; x++) {
                for (let y = 0; y < state.rows; y++) {
                    const cell = state.grass[x][y];
                    if (!cell.active || !cell.sprite) continue;
                    
                    if (cell.height <= 0) {
                        cell.sprite.visible = false;
                        continue;
                    }
                    
                    cell.sprite.visible = true;
                    activeCount++;
                    
                    const baseSway = fastSin(state.time * cell.swaySpeed + cell.offset) * 2;
                    const totalSway = baseSway + cell.sway + cell.impactSway;
                    const isNearMouse = Math.abs(x - mouseGridX) <= 2 && Math.abs(y - mouseGridY) <= 2;
                    
                    cell.sprite.height = cell.height;
                    cell.sprite.rotation = (totalSway / cell.height) * 0.3;
                    
                    if (isNearMouse && cell.height > cell.maxHeight * 0.7) {
                        cell.sprite.tint = 0xbbffbb;
                    } else if (cell.wetness > 0) {
                        const wetFactor = cell.wetness;
                        const r = Math.floor(GRASS_COLORS[cell.colorIndex][0] * (1 - wetFactor * 0.3));
                        const g = Math.floor(GRASS_COLORS[cell.colorIndex][1] * (1 - wetFactor * 0.3) + 20 * wetFactor);
                        const b = Math.floor(GRASS_COLORS[cell.colorIndex][2] * (1 - wetFactor * 0.3) + 40 * wetFactor);
                        cell.sprite.tint = rgbToHex(r, g, b);
                    } else {
                        cell.sprite.tint = 0xffffff;
                    }
                }
            }
            
            return activeCount;
        }
        
        function renderFlowers() {
            for (const flower of state.flowers) {
                flower.graphics.clear();
                
                if (flower.height <= 5) continue;
                
                const baseX = (flower.x * config.gridSize) | 0;
                const baseY = (flower.y * config.gridSize) | 0;
                const stemHeight = flower.height | 0;
                
                flower.graphics.beginFill(0x2d5a3d);
                flower.graphics.drawRect(baseX, baseY - stemHeight, 2, stemHeight);
                flower.graphics.endFill();
                
                if (flower.height >= flower.maxHeight * 0.8) {
                    const flowerTop = baseY - stemHeight;
                    const [r, g, b] = FLOWER_COLORS[flower.colorIndex];
                    
                    for (let p = 0; p < 8; p++) {
                        const angle = (Math.PI * 0.25 * p) + flower.rotation;
                        const petalX = baseX + fastCos(angle) * flower.petalSize * 2;
                        const petalY = flowerTop + fastSin(angle) * flower.petalSize * 2;
                        
                        flower.graphics.beginFill(rgbToHex(r, g, b));
                        flower.graphics.drawRect(
                            petalX | 0, 
                            petalY | 0, 
                            Math.ceil(flower.petalSize), 
                            Math.ceil(flower.petalSize)
                        );
                        flower.graphics.endFill();
                    }
                    
                    flower.graphics.beginFill(0xffdd44);
                    flower.graphics.drawRect(baseX - 1, flowerTop - 1, 3, 3);
                    flower.graphics.endFill();
                }
            }
        }
        
        function renderFireflies() {
            for (const firefly of state.fireflies) {
                const pulse = fastSin(state.time * firefly.pulseSpeed) * 0.3 + 0.7;
                
                firefly.sprite.x = firefly.x;
                firefly.sprite.y = firefly.y;
                firefly.sprite.alpha = firefly.alpha * pulse;
            }
        }
        
        function renderRain() {
            for (const drop of state.raindrops) {
                drop.sprite.x = drop.x;
                drop.sprite.y = drop.y;
                
                const angle = Math.atan2(drop.vy, drop.vx);
                drop.sprite.rotation = angle + Math.PI / 2;
            }
        }
        
        function renderSplashes() {
            for (const splash of state.splashes) {
                splash.sprite.x = splash.x;
                splash.sprite.y = splash.y;
                
                const fadeAlpha = (splash.life / 30) * splash.alpha;
                splash.sprite.alpha = fadeAlpha;
            }
        }
        
        app.ticker.add(() => {
            const now = performance.now();
            const delta = now - state.lastTime;
            state.lastTime = now;
            
            state.frames++;
            state.fpsTime += delta;
            
            if (state.fpsTime >= 1000) {
                state.fps = (state.frames * 1000 / state.fpsTime) | 0;
                document.getElementById('stat_fps').textContent = state.fps;
                state.frames = 0;
                state.fpsTime = 0;
            }
            
            state.time += 0.016 * config.speed;
            
            updateGrassChunked();
            updateFlowers();
            updateFireflies();
            updateRain();
            updateSplashes();
            updateImpacts();
            
            const grassCount = renderGrass();
            renderFlowers();
            renderFireflies();
            renderRain();
            renderSplashes();
            
            document.getElementById('stat_grass').textContent = grassCount;
            document.getElementById('stat_flowers').textContent = state.flowers.length;
            document.getElementById('stat_fireflies').textContent = state.fireflies.length;
            document.getElementById('stat_rain').textContent = state.raindrops.length;
            document.getElementById('stat_splashes').textContent = state.splashes.length;
            document.getElementById('stat_chunks').textContent = state.chunks.length;
        });
        
        function togglePanel() {
            document.getElementById('panel').classList.toggle('open');
        }
        
        function togglePause() {
            state.isGrowing = !state.isGrowing;
            const btn = document.getElementById('pauseBtn');
            btn.textContent = state.isGrowing ? '‚è∏ Pausar' : '‚ñ∂ Continuar';
        }
        
        function toggleRain() {
            state.isRaining = !state.isRaining;
            const btn = document.getElementById('rainBtn');
            btn.textContent = state.isRaining ? 'üåßÔ∏è Parar' : 'üåßÔ∏è Chuva';
            btn.classList.toggle('active', state.isRaining);
        }
        
        function resetGarden() {
            initializeGarden();
        }
        
        function updateConfig(key, value) {
            const valueNum = parseFloat(value);
            
            const configMap = {
                chunkSize: () => {
                    config.chunkSize = valueNum;
                    document.getElementById('val_chunkSize').textContent = valueNum + 'x' + valueNum;
                    initializeChunks();
                },
                chunksPerFrame: () => {
                    config.chunksPerFrame = valueNum;
                    document.getElementById('val_chunksPerFrame').textContent = valueNum;
                },
                gridSize: () => {
                    config.gridSize = valueNum;
                    document.getElementById('val_gridSize').textContent = valueNum + 'px';
                    initializeGarden();
                },
                density: () => {
                    config.density = valueNum;
                    document.getElementById('val_density').textContent = valueNum + '%';
                    initializeGarden();
                },
                height: () => {
                    config.height = valueNum;
                    document.getElementById('val_height').textContent = valueNum.toFixed(1) + 'x';
                    initializeGarden();
                },
                speed: () => {
                    config.speed = valueNum;
                    document.getElementById('val_speed').textContent = valueNum.toFixed(1) + 'x';
                },
                particles: () => {
                    config.particles = valueNum;
                    document.getElementById('val_particles').textContent = valueNum;
                    backgroundContainer.removeChildren();
                    if (valueNum > 0) {
                        backgroundParticles = createBackgroundParticles();
                        backgroundContainer.addChild(backgroundParticles);
                    }
                },
                maxFireflies: () => {
                    config.maxFireflies = valueNum;
                    document.getElementById('val_maxFireflies').textContent = valueNum;
                },
                rainIntensity: () => {
                    config.rainIntensity = valueNum;
                    document.getElementById('val_rainIntensity').textContent = valueNum;
                },
                dropSize: () => {
                    config.dropSize = valueNum;
                    document.getElementById('val_dropSize').textContent = valueNum.toFixed(1) + 'x';
                },
                rainSpeed: () => {
                    config.rainSpeed = valueNum;
                    document.getElementById('val_rainSpeed').textContent = valueNum.toFixed(1) + 'x';
                },
                windForce: () => {
                    config.windForce = valueNum;
                    document.getElementById('val_windForce').textContent = valueNum.toFixed(1);
                },
                impactForce: () => {
                    config.impactForce = valueNum;
                    document.getElementById('val_impactForce').textContent = valueNum.toFixed(1) + 'x';
                },
                splashAmount: () => {
                    config.splashAmount = valueNum;
                    document.getElementById('val_splashAmount').textContent = valueNum;
                }
            };
            
            if (configMap[key]) {
                configMap[key]();
            }
        }
        
        function applyPreset(presetName) {
            const presets = {
                low: {
                    chunkSize: 32,
                    chunksPerFrame: 2,
                    gridSize: 6,
                    density: 50,
                    height: 0.8,
                    particles: 30,
                    maxFireflies: 100,
                    rainIntensity: 30,
                    dropSize: 0.8,
                    rainSpeed: 0.8,
                    windForce: 0,
                    impactForce: 0.7,
                    splashAmount: 3
                },
                medium: {
                    chunkSize: 16,
                    chunksPerFrame: 4,
                    gridSize: 4,
                    density: 75,
                    height: 1,
                    particles: 100,
                    maxFireflies: 200,
                    rainIntensity: 50,
                    dropSize: 1,
                    rainSpeed: 1,
                    windForce: 0,
                    impactForce: 1,
                    splashAmount: 5
                },
                high: {
                    chunkSize: 12,
                    chunksPerFrame: 6,
                    gridSize: 3,
                    density: 100,
                    height: 1.2,
                    particles: 150,
                    maxFireflies: 300,
                    rainIntensity: 70,
                    dropSize: 1.3,
                    rainSpeed: 1.2,
                    windForce: 1,
                    impactForce: 1.5,
                    splashAmount: 7
                },
                ultra: {
                    chunkSize: 8,
                    chunksPerFrame: 8,
                    gridSize: 2,
                    density: 100,
                    height: 1.5,
                    particles: 200,
                    maxFireflies: 400,
                    rainIntensity: 90,
                    dropSize: 1.5,
                    rainSpeed: 1.5,
                    windForce: 2,
                    impactForce: 2,
                    splashAmount: 10
                },
                retro: {
                    chunkSize: 32,
                    chunksPerFrame: 2,
                    gridSize: 8,
                    density: 60,
                    height: 0.6,
                    particles: 50,
                    maxFireflies: 50,
                    rainIntensity: 20,
                    dropSize: 0.5,
                    rainSpeed: 0.6,
                    windForce: 0,
                    impactForce: 0.5,
                    splashAmount: 2
                },
                storm: {
                    chunkSize: 16,
                    chunksPerFrame: 6,
                    gridSize: 3,
                    density: 100,
                    height: 1,
                    particles: 80,
                    maxFireflies: 150,
                    rainIntensity: 100,
                    dropSize: 2,
                    rainSpeed: 2,
                    windForce: 4,
                    impactForce: 2.5,
                    splashAmount: 10
                }
            };
            
            const preset = presets[presetName];
            if (!preset) return;
            
            Object.assign(config, preset);
            
            const inputs = document.querySelectorAll('input[type="range"]');
            inputs[0].value = config.chunkSize;
            inputs[1].value = config.chunksPerFrame;
            inputs[2].value = config.gridSize;
            inputs[3].value = config.density;
            inputs[4].value = config.height;
            inputs[5].value = config.rainIntensity;
            inputs[6].value = config.dropSize;
            inputs[7].value = config.rainSpeed;
            inputs[8].value = config.windForce;
            inputs[9].value = config.impactForce;
            inputs[10].value = config.splashAmount;
            inputs[11].value = config.speed;
            inputs[12].value = config.particles;
            inputs[13].value = config.maxFireflies;
            
            document.getElementById('val_chunkSize').textContent = config.chunkSize + 'x' + config.chunkSize;
            document.getElementById('val_chunksPerFrame').textContent = config.chunksPerFrame;
            document.getElementById('val_gridSize').textContent = config.gridSize + 'px';
            document.getElementById('val_density').textContent = config.density + '%';
            document.getElementById('val_height').textContent = config.height.toFixed(1) + 'x';
            document.getElementById('val_rainIntensity').textContent = config.rainIntensity;
            document.getElementById('val_dropSize').textContent = config.dropSize.toFixed(1) + 'x';
            document.getElementById('val_rainSpeed').textContent = config.rainSpeed.toFixed(1) + 'x';
            document.getElementById('val_windForce').textContent = config.windForce.toFixed(1);
            document.getElementById('val_impactForce').textContent = config.impactForce.toFixed(1) + 'x';
            document.getElementById('val_splashAmount').textContent = config.splashAmount;
            document.getElementById('val_speed').textContent = config.speed.toFixed(1) + 'x';
            document.getElementById('val_particles').textContent = config.particles;
            document.getElementById('val_maxFireflies').textContent = config.maxFireflies;
            
            initializeGarden();
        }
        
        function showUI() {
            state.uiVisible = true;
            const btn = document.querySelector('.config-btn');
            btn.style.opacity = '1';
            btn.style.pointerEvents = 'auto';
        }
        
        function hideUI() {
            const panel = document.getElementById('panel');
            if (panel.classList.contains('open')) return;
            
            state.uiVisible = false;
            const btn = document.querySelector('.config-btn');
            btn.style.opacity = '0';
            btn.style.pointerEvents = 'none';
        }
        
        function checkUITimeout() {
            if (Date.now() - state.lastMouseMove > 5000) {
                hideUI();
            }
        }
        
        function handleMouseMove() {
            state.lastMouseMove = Date.now();
            if (!state.uiVisible) {
                showUI();
            }
        }
        
        app.view.addEventListener('mousemove', (e) => {
            const rect = app.view.getBoundingClientRect();
            state.mouseX = e.clientX - rect.left;
            state.mouseY = e.clientY - rect.top;
        });
        
        app.view.addEventListener('mousedown', () => {
            state.isMouseDown = true;
        });
        
        app.view.addEventListener('mouseup', () => {
            state.isMouseDown = false;
        });
        
        app.view.addEventListener('mouseleave', () => {
            state.mouseX = -100;
            state.mouseY = -100;
            state.isMouseDown = false;
        });
        
        app.view.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const rect = app.view.getBoundingClientRect();
            const touch = e.touches[0];
            state.mouseX = touch.clientX - rect.left;
            state.mouseY = touch.clientY - rect.top;
        }, { passive: false });
        
        app.view.addEventListener('touchstart', () => {
            state.isMouseDown = true;
        });
        
        app.view.addEventListener('touchend', () => {
            state.isMouseDown = false;
        });
        
        document.addEventListener('mousemove', handleMouseMove);
        
        document.addEventListener('keydown', (e) => {
            if (e.key === 'F11' || e.key === 'f') {
                handleMouseMove();
            }
        });
        
        setInterval(checkUITimeout, 1000);
        
        initializeGarden();
    </script>
</body>
</html>
