<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jardim Pixel</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.3.2/pixi.min.js"></script>
    <style>
        * { 
            margin: 0; 
            padding: 0; 
            box-sizing: border-box; 
        }
        
        body {
            background: #1a1a2e;
            font-family: 'Courier New', monospace;
            color: #fff;
            overflow: hidden;
            height: 100vh;
        }
        
        #pixelGarden {
            display: block;
            cursor: crosshair;
            width: 100vw;
            height: 100vh;
        }
        
        .config-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            background: rgba(74, 222, 128, 0.9);
            border: 3px solid #4ade80;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            transition: all 0.3s, opacity 0.5s;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 1000;
        }
        
        .config-btn:hover {
            background: #4ade80;
            transform: rotate(90deg) scale(1.1);
        }
        
        .panel {
            position: fixed;
            top: 0;
            right: -420px;
            width: 420px;
            height: 100vh;
            background: rgba(26, 26, 46, 0.98);
            backdrop-filter: blur(10px);
            border-left: 3px solid #4ade80;
            padding: 30px;
            overflow-y: auto;
            transition: right 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            z-index: 999;
            box-shadow: -5px 0 20px rgba(0, 0, 0, 0.5);
        }
        
        .panel.open { 
            right: 0; 
        }
        
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 15px;
            border-bottom: 2px solid #4ade80;
        }
        
        h2 {
            color: #4ade80;
            font-size: 1.8rem;
            text-shadow: 0 0 10px rgba(74, 222, 128, 0.5);
        }
        
        .close {
            background: #ef4444;
            color: white;
            border: none;
            width: 35px;
            height: 35px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 20px;
            transition: all 0.3s;
        }
        
        .close:hover {
            background: #dc2626;
            transform: rotate(90deg);
        }
        
        .section {
            margin-bottom: 25px;
        }
        
        h3 {
            color: #86efac;
            font-size: 1.1rem;
            margin-bottom: 15px;
            padding-left: 10px;
            border-left: 3px solid #4ade80;
        }
        
        .control {
            margin-bottom: 20px;
            background: rgba(30, 41, 59, 0.5);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #374151;
        }
        
        .label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            color: #d1d5db;
            font-size: 0.95rem;
        }
        
        .value {
            color: #4ade80;
            font-weight: bold;
            min-width: 60px;
            text-align: right;
        }
        
        input[type="range"] {
            width: 100%;
            height: 8px;
            -webkit-appearance: none;
            background: #374151;
            border-radius: 4px;
            outline: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: #4ade80;
            border-radius: 50%;
            cursor: pointer;
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #4ade80;
            border-radius: 50%;
            border: none;
        }

        input[type="color"] {
            width: 100%;
            height: 40px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            background: #374151;
        }
        
        /* NOVOS ESTILOS - Sistema de Presets */
        input[type="file"] {
            display: none;
        }
        
        .file-btn {
            background: #6366f1;
            color: white;
            border: none;
            padding: 12px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            font-size: 0.95rem;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            width: 100%;
            margin-bottom: 10px;
        }
        
        .file-btn:hover {
            background: #4f46e5;
            transform: translateY(-2px);
        }
        
        .toggle-container {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }
        
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 30px;
        }
        
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #374151;
            transition: 0.4s;
            border-radius: 30px;
        }
        
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 22px;
            width: 22px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: 0.4s;
            border-radius: 50%;
        }
        
        input:checked + .toggle-slider {
            background-color: #4ade80;
        }
        
        input:checked + .toggle-slider:before {
            transform: translateX(30px);
        }
        
        .season-indicator {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.85rem;
            background: rgba(74, 222, 128, 0.2);
            border: 1px solid #4ade80;
            color: #4ade80;
            margin-left: 10px;
        }
        /* FIM NOVOS ESTILOS */
        
        .btns {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 10px;
        }
        
        button {
            background: #4ade80;
            color: #1a1a2e;
            border: none;
            padding: 12px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            font-size: 0.95rem;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        button:hover {
            background: #22c55e;
            transform: translateY(-2px);
        }
        
        .reset { 
            background: #ef4444; 
        }
        
        .reset:hover { 
            background: #dc2626; 
        }
        
        .pause { 
            background: #f59e0b; 
        }
        
        .pause:hover { 
            background: #d97706; 
        }
        
        .rain { 
            background: #3b82f6; 
        }
        
        .rain:hover { 
            background: #2563eb; 
        }
        
        .rain.active {
            background: #1e40af;
            box-shadow: 0 0 20px rgba(59, 130, 246, 0.5);
        }
        
        .stats {
            background: rgba(30, 41, 59, 0.8);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #374151;
        }
        
        .stat {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #374151;
            color: #60a5fa;
        }
        
        .stat:last-child { 
            border-bottom: none; 
        }
        
        .stat span:last-child {
            color: #4ade80;
            font-weight: bold;
        }
        
        .presets {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 8px;
        }
        
        .preset {
            padding: 8px;
            font-size: 0.85rem;
            background: rgba(74, 222, 128, 0.2);
            border: 1px solid #4ade80;
            color: #4ade80;
        }
        
        .preset:hover {
            background: rgba(74, 222, 128, 0.3);
        }
        
        .info-box {
            background: rgba(59, 130, 246, 0.1);
            border: 1px solid rgba(59, 130, 246, 0.3);
            padding: 12px;
            border-radius: 6px;
            font-size: 0.85rem;
            color: #93c5fd;
            margin-top: 10px;
        }
        
        @media (max-width: 768px) {
            .panel { 
                width: 100vw; 
                right: -100vw; 
            }
            .config-btn { 
                top: 10px; 
                right: 10px; 
                width: 45px; 
                height: 45px; 
            }
        }
        
        ::-webkit-scrollbar { 
            width: 8px; 
        }
        
        ::-webkit-scrollbar-track { 
            background: rgba(30, 41, 59, 0.5); 
        }
        
        ::-webkit-scrollbar-thumb { 
            background: #4ade80; 
            border-radius: 4px; 
        }
    </style>
</head>
<body>
    <div id="pixelGarden"></div>
    <div class="config-btn" onclick="togglePanel()">‚öôÔ∏è</div>
    
    <div class="panel" id="panel">
        <div class="header">
            <h2>‚öôÔ∏è Configura√ß√µes</h2>
            <button class="close" onclick="togglePanel()">‚úï</button>
        </div>
        
        <div class="section">
            <h3>üéÆ Controles</h3>
            <div class="btns">
                <button class="pause" id="pauseBtn" onclick="togglePause()">‚è∏ Pausar</button>
                <button class="reset" onclick="resetGarden()">üîÑ Reset</button>
                <button class="rain" id="rainBtn" onclick="toggleRain()">üåßÔ∏è Chuva</button>
            </div>
        </div>

        <!-- NOVA SE√á√ÉO - Cores Customizadas -->
        <div class="section">
            <h3>üé® Cores da Grama</h3>
            <div class="control">
                <div class="label">
                    <span>Cor Clara (Topo)</span>
                </div>
                <input type="color" id="lightGrassColor" value="#7daf7e" 
                       oninput="updateCustomGrassColors()">
            </div>
            <div class="control">
                <div class="label">
                    <span>Cor Escura (Base)</span>
                </div>
                <input type="color" id="darkGrassColor" value="#1a4d2e" 
                       oninput="updateCustomGrassColors()">
            </div>
        </div>
        <!-- FIM NOVA SE√á√ÉO -->

        <!-- NOVA SE√á√ÉO - Modo Autom√°tico e Esta√ß√µes -->
        <div class="section">
            <h3>üåç Esta√ß√µes do Ano</h3>
            <div class="control">
                <div class="toggle-container">
                    <span>Modo Autom√°tico</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="autoSeasonToggle" onchange="toggleAutoSeason()">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <div id="currentSeasonDisplay" style="margin-top: 10px; color: #86efac; text-align: center;">
                    Esta√ß√£o atual: <span class="season-indicator" id="seasonName">-</span>
                </div>
            </div>
            <div class="presets">
                <button class="preset" onclick="applySeasonPreset('spring')">üå∏ Primavera</button>
                <button class="preset" onclick="applySeasonPreset('summer')">‚òÄÔ∏è Ver√£o</button>
                <button class="preset" onclick="applySeasonPreset('autumn')">üçÇ Outono</button>
                <button class="preset" onclick="applySeasonPreset('winter')">‚ùÑÔ∏è Inverno</button>
            </div>
            <div class="info-box">
                üí° No modo autom√°tico, as cores mudam de acordo com a √©poca do ano. Voc√™ pode sobrescrever manualmente a qualquer momento.
            </div>
        </div>
        <!-- FIM NOVA SE√á√ÉO -->

        <!-- NOVA SE√á√ÉO - Sistema de Presets -->
        <div class="section">
            <h3>üíæ Gerenciar Presets</h3>
            <button class="file-btn" onclick="exportPreset()">üì§ Exportar Preset</button>
            <button class="file-btn" onclick="document.getElementById('importPresetFile').click()">üì• Importar Preset</button>
            <input type="file" id="importPresetFile" accept=".json" onchange="importPreset(event)">
            <div class="info-box">
                üí° Seus presets s√£o salvos automaticamente no navegador. Use Exportar/Importar para compartilhar ou fazer backup.
            </div>
        </div>
        <!-- FIM NOVA SE√á√ÉO -->

        <div class="section">
            <h3>üïê Rel√≥gio</h3>
            <div class="control">
                <div class="label">
                    <span>Tamanho da Fonte</span>
                    <span class="value" id="val_clockSize">48px</span>
                </div>
                <input type="range" min="8" max="900" step="4" value="48" 
                       oninput="updateConfig('clockSize', this.value)">
            </div>
            <div class="control">
                <div class="label">
                    <span>Grossura da Fonte</span>
                    <span class="value" id="val_clockWeight">300</span>
                </div>
                <input type="range" min="100" max="900" step="100" value="300" 
                       oninput="updateConfig('clockWeight', this.value)">
            </div>
            <div class="control">
                <div class="label">
                    <span>Posi√ß√£o Horizontal</span>
                    <span class="value" id="val_clockX">-40px</span>
                </div>
                <input type="range" min="-8000" max="8000" step="5" value="-40" 
                       oninput="updateConfig('clockX', this.value)">
            </div>
            <div class="control">
                <div class="label">
                    <span>Posi√ß√£o Vertical</span>
                    <span class="value" id="val_clockY">-40px</span>
                </div>
                <input type="range" min="-8000" max="8000" step="5" value="-40" 
                       oninput="updateConfig('clockY', this.value)">
            </div>
            <div class="control">
                <div class="label">
                    <span>Cor</span>
                </div>
                <input type="color" value="#d4f4dd" 
                       oninput="updateConfig('clockColor', this.value)">
            </div>
            <div class="control">
                <div class="label">
                    <span>Transpar√™ncia</span>
                    <span class="value" id="val_clockAlpha">0.30</span>
                </div>
                <input type="range" min="0.1" max="1" step="0.05" value="0.30" 
                       oninput="updateConfig('clockAlpha', this.value)">
            </div>
        </div>
        
        <div class="section">
            <h3>‚ö° Otimiza√ß√£o de Chunks</h3>
            <div class="control">
                <div class="label">
                    <span>Tamanho do Chunk</span>
                    <span class="value" id="val_chunkSize">16x16</span>
                </div>
                <input type="range" min="8" max="64" step="8" value="16" 
                       oninput="updateConfig('chunkSize', this.value)">
            </div>
            <div class="control">
                <div class="label">
                    <span>Chunks por Frame</span>
                    <span class="value" id="val_chunksPerFrame">4</span>
                </div>
                <input type="range" min="1" max="16" step="1" value="4" 
                       oninput="updateConfig('chunksPerFrame', this.value)">
            </div>
            <div class="info-box">
                üí° <strong>Chunks</strong> dividem o processamento em partes menores para melhor performance. Aumente se tiver FPS alto, diminua se estiver travando.
            </div>
        </div>
        
        <div class="section">
            <h3>üìê Tamanho</h3>
            <div class="control">
                <div class="label">
                    <span>Tamanho do Pixel</span>
                    <span class="value" id="val_gridSize">4px</span>
                </div>
                <input type="range" min="2" max="8" value="4" 
                       oninput="updateConfig('gridSize', this.value)">
            </div>
            <div class="control">
                <div class="label">
                    <span>Densidade</span>
                    <span class="value" id="val_density">100%</span>
                </div>
                <input type="range" min="10" max="100" step="5" value="100" 
                       oninput="updateConfig('density', this.value)">
            </div>
            <div class="control">
                <div class="label">
                    <span>Altura</span>
                    <span class="value" id="val_height">1.0x</span>
                </div>
                <input type="range" min="0.5" max="2" step="0.1" value="1" 
                       oninput="updateConfig('height', this.value)">
            </div>
        </div>
        
        <div class="section">
            <h3>üåßÔ∏è Sistema de Chuva</h3>
            <div class="control">
                <div class="label">
                    <span>Intensidade</span>
                    <span class="value" id="val_rainIntensity">50</span>
                </div>
                <input type="range" min="10" max="100" step="5" value="50" 
                       oninput="updateConfig('rainIntensity', this.value)">
            </div>
            <div class="control">
                <div class="label">
                    <span>Tamanho dos Pingos</span>
                    <span class="value" id="val_dropSize">1.0x</span>
                </div>
                <input type="range" min="0.5" max="3" step="0.1" value="1" 
                       oninput="updateConfig('dropSize', this.value)">
            </div>
            <div class="control">
                <div class="label">
                    <span>Velocidade</span>
                    <span class="value" id="val_rainSpeed">1.0x</span>
                </div>
                <input type="range" min="0.5" max="2.5" step="0.1" value="1" 
                       oninput="updateConfig('rainSpeed', this.value)">
            </div>
            <div class="control">
                <div class="label">
                    <span>Dire√ß√£o Horizontal</span>
                    <span class="value" id="val_windForce">0</span>
                </div>
                <input type="range" min="-5" max="5" step="0.5" value="0" 
                       oninput="updateConfig('windForce', this.value)">
            </div>
            <div class="control">
                <div class="label">
                    <span>For√ßa de Impacto</span>
                    <span class="value" id="val_impactForce">1.0x</span>
                </div>
                <input type="range" min="0.5" max="3" step="0.1" value="1" 
                       oninput="updateConfig('impactForce', this.value)">
            </div>
            <div class="control">
                <div class="label">
                    <span>Respingos</span>
                    <span class="value" id="val_splashAmount">5</span>
                </div>
                <input type="range" min="0" max="10" step="1" value="5" 
                       oninput="updateConfig('splashAmount', this.value)">
            </div>
        </div>
        
        <div class="section">
            <h3>‚ö° Performance</h3>
            <div class="control">
                <div class="label">
                    <span>Velocidade Global</span>
                    <span class="value" id="val_speed">1.0x</span>
                </div>
                <input type="range" min="0.1" max="3" step="0.1" value="1" 
                       oninput="updateConfig('speed', this.value)">
            </div>
            <div class="control">
                <div class="label">
                    <span>Part√≠culas de Fundo</span>
                    <span class="value" id="val_particles">100</span>
                </div>
                <input type="range" min="0" max="300" step="10" value="100" 
                       oninput="updateConfig('particles', this.value)">
            </div>
            <div class="control">
                <div class="label">
                    <span>Max Vagalumes</span>
                    <span class="value" id="val_maxFireflies">200</span>
                </div>
                <input type="range" min="50" max="500" step="25" value="200" 
                       oninput="updateConfig('maxFireflies', this.value)">
            </div>
        </div>
        
        <div class="section">
            <h3>üéØ Presets</h3>
            <div class="presets">
                <button class="preset" onclick="applyPreset('low')">Baixo</button>
                <button class="preset" onclick="applyPreset('medium')">M√©dio</button>
                <button class="preset" onclick="applyPreset('high')">Alto</button>
                <button class="preset" onclick="applyPreset('ultra')">Ultra</button>
                <button class="preset" onclick="applyPreset('retro')">Retro</button>
                <button class="preset" onclick="applyPreset('storm')">‚õàÔ∏è Tempestade</button>
            </div>
        </div>
        
        <div class="section">
            <h3>üìä Estat√≠sticas</h3>
            <div class="stats">
                <div class="stat">
                    <span>üå± Grama Ativa</span>
                    <span id="stat_grass">0</span>
                </div>
                <div class="stat">
                    <span>üå∏ Flores</span>
                    <span id="stat_flowers">0</span>
                </div>
                <div class="stat">
                    <span>‚ú® Vagalumes</span>
                    <span id="stat_fireflies">0</span>
                </div>
                <div class="stat">
                    <span>üíß Gotas de Chuva</span>
                    <span id="stat_rain">0</span>
                </div>
                <div class="stat">
                    <span>üí¶ Respingos</span>
                    <span id="stat_splashes">0</span>
                </div>
                <div class="stat">
                    <span>üì¶ Total de Chunks</span>
                    <span id="stat_chunks">0</span>
                </div>
                <div class="stat">
                    <span>‚ö° FPS</span>
                    <span id="stat_fps">60</span>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        const app = new PIXI.Application({
            background: '#2a1810',
            resizeTo: window,
            antialias: false,
            resolution: 1
        });
        
        document.getElementById('pixelGarden').appendChild(app.view);
        
        const backgroundContainer = new PIXI.Container();
        const grassContainer = new PIXI.Container();
        const flowerContainer = new PIXI.Container();
        const fireflyContainer = new PIXI.ParticleContainer(500, {
            scale: true,
            position: true,
            rotation: false,
            tint: true,
            alpha: true
        });
        const rainContainer = new PIXI.ParticleContainer(1000, {
            scale: true,
            position: true,
            rotation: true,
            tint: false,
            alpha: true
        });
        const splashContainer = new PIXI.ParticleContainer(500, {
            scale: true,
            position: true,
            rotation: false,
            tint: false,
            alpha: true
        });
        const clockContainer = new PIXI.Container();
        
        app.stage.addChild(backgroundContainer);
        app.stage.addChild(grassContainer);
        app.stage.addChild(flowerContainer);
        app.stage.addChild(fireflyContainer);
        app.stage.addChild(rainContainer);
        app.stage.addChild(splashContainer);
        app.stage.addChild(clockContainer);
        
        const config = {
            gridSize: 4,
            density: 100,
            height: 1,
            speed: 1,
            particles: 100,
            maxFireflies: 200,
            chunkSize: 16,
            chunksPerFrame: 4,
            rainIntensity: 50,
            dropSize: 1,
            rainSpeed: 1,
            windForce: 0,
            impactForce: 1,
            splashAmount: 5,
            clockSize: 48,
            clockWeight: 300,
            clockX: -40,
            clockY: -40,
            clockColor: '#d4f4dd',
            clockAlpha: 0.30
        };
        
        const state = {
            cols: 0,
            rows: 0,
            grass: [],
            flowers: [],
            fireflies: [],
            raindrops: [],
            splashes: [],
            impacts: [],
            fireflyPool: [],
            raindropPool: [],
            splashPool: [],
            chunks: [],
            chunkCols: 0,
            chunkRows: 0,
            currentChunkIndex: 0,
            isGrowing: true,
            isRaining: false,
            mouseX: -100,
            mouseY: -100,
            isMouseDown: false,
            time: 0,
            fps: 60,
            lastTime: performance.now(),
            frames: 0,
            fpsTime: 0,
            uiVisible: true,
            lastMouseMove: Date.now(),
            currentMinute: -1
        };
        
        const GRASS_COLORS = [
            [26, 77, 46],
            [45, 90, 61],
            [61, 107, 74],
            [77, 124, 91],
            [93, 141, 108],
            [109, 158, 125],
            [125, 175, 142]
        ];
        
        const FLOWER_COLORS = [
            [255, 68, 68],
            [255, 107, 107],
            [255, 170, 68],
            [255, 221, 68],
            [255, 68, 170],
            [170, 68, 255],
            [68, 68, 255]
        ];

        // ============================================================
        // NOVO C√ìDIGO - Sistema de Cores Customizadas e Esta√ß√µes
        // ============================================================
        
        // Presets de cores para esta√ß√µes
        const SEASON_PRESETS = {
            spring: {
                name: 'üå∏ Primavera',
                lightColor: '#7daf7e',
                darkColor: '#1a4d2e'
            },
            summer: {
                name: '‚òÄÔ∏è Ver√£o',
                lightColor: '#9ed99c',
                darkColor: '#2d5a3d'
            },
            autumn: {
                name: 'üçÇ Outono',
                lightColor: '#d4a574',
                darkColor: '#8b5a3c'
            },
            winter: {
                name: '‚ùÑÔ∏è Inverno',
                lightColor: '#b8d4d4',
                darkColor: '#4a6b6b'
            }
        };

        // Estado adicional para gerenciar cores customizadas
        const customColorState = {
            isAutoSeasonEnabled: false,
            currentSeason: null,
            customLightColor: '#7daf7e',
            customDarkColor: '#1a4d2e',
            isUsingCustomColors: false
        };

        // Fun√ß√£o para detectar a esta√ß√£o atual baseada na data
        function detectCurrentSeason() {
            const now = new Date();
            const month = now.getMonth() + 1; // getMonth() retorna 0-11
            
            // Hemisf√©rio Sul (Brasil)
            if (month >= 9 && month <= 11) return 'spring';      // Set-Nov
            if (month >= 12 || month <= 2) return 'summer';       // Dez-Fev
            if (month >= 3 && month <= 5) return 'autumn';        // Mar-Mai
            if (month >= 6 && month <= 8) return 'winter';        // Jun-Ago
            
            return 'spring';
        }

        // Fun√ß√£o para aplicar preset de esta√ß√£o
        function applySeasonPreset(seasonKey) {
            const preset = SEASON_PRESETS[seasonKey];
            if (!preset) return;
            
            // Desativa o modo autom√°tico quando o usu√°rio escolhe manualmente
            customColorState.isAutoSeasonEnabled = false;
            document.getElementById('autoSeasonToggle').checked = false;
            
            customColorState.customLightColor = preset.lightColor;
            customColorState.customDarkColor = preset.darkColor;
            customColorState.currentSeason = seasonKey;
            customColorState.isUsingCustomColors = true;
            
            // Atualiza os color pickers
            document.getElementById('lightGrassColor').value = preset.lightColor;
            document.getElementById('darkGrassColor').value = preset.darkColor;
            
            // Atualiza o indicador de esta√ß√£o
            document.getElementById('seasonName').textContent = preset.name;
            
            // Regenera as texturas e o jardim
            regenerateGrassWithCustomColors();
            
            // Salva automaticamente
            savePresetToLocalStorage();
        }

        // Fun√ß√£o para alternar modo autom√°tico de esta√ß√µes
        function toggleAutoSeason() {
            customColorState.isAutoSeasonEnabled = document.getElementById('autoSeasonToggle').checked;
            
            if (customColorState.isAutoSeasonEnabled) {
                // Aplica a esta√ß√£o atual automaticamente
                const currentSeason = detectCurrentSeason();
                applySeasonPreset(currentSeason);
                customColorState.isAutoSeasonEnabled = true; // Reativa ap√≥s applySeasonPreset desativar
                document.getElementById('autoSeasonToggle').checked = true;
            }
            
            savePresetToLocalStorage();
        }

        // Fun√ß√£o para atualizar cores customizadas em tempo real
        function updateCustomGrassColors() {
            customColorState.customLightColor = document.getElementById('lightGrassColor').value;
            customColorState.customDarkColor = document.getElementById('darkGrassColor').value;
            customColorState.isUsingCustomColors = true;
            
            // Desativa o modo autom√°tico quando o usu√°rio customiza manualmente
            customColorState.isAutoSeasonEnabled = false;
            document.getElementById('autoSeasonToggle').checked = false;
            customColorState.currentSeason = null;
            document.getElementById('seasonName').textContent = 'Customizado';
            
            // Regenera as texturas e o jardim
            regenerateGrassWithCustomColors();
            
            // Salva automaticamente
            savePresetToLocalStorage();
        }

        // Fun√ß√£o para converter hex para RGB
        function hexToRgbArray(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? [
                parseInt(result[1], 16),
                parseInt(result[2], 16),
                parseInt(result[3], 16)
            ] : [125, 175, 126];
        }

        // Fun√ß√£o para interpolar entre duas cores
        function interpolateColor(color1, color2, factor) {
            return [
                Math.round(color1[0] + (color2[0] - color1[0]) * factor),
                Math.round(color1[1] + (color2[1] - color1[1]) * factor),
                Math.round(color1[2] + (color2[2] - color1[2]) * factor)
            ];
        }

        // Fun√ß√£o para gerar paleta de cores baseada em duas cores
        function generateGrassColorPalette(darkColorHex, lightColorHex) {
            const darkRgb = hexToRgbArray(darkColorHex);
            const lightRgb = hexToRgbArray(lightColorHex);
            
            const palette = [];
            const steps = 7; // Mesmo n√∫mero de cores do GRASS_COLORS original
            
            for (let i = 0; i < steps; i++) {
                const factor = i / (steps - 1);
                palette.push(interpolateColor(darkRgb, lightRgb, factor));
            }
            
            return palette;
        }

        // Fun√ß√£o para regenerar texturas da grama com cores customizadas
        function regenerateGrassWithCustomColors() {
            if (!customColorState.isUsingCustomColors) return;
            
            // Gera nova paleta
            const newPalette = generateGrassColorPalette(
                customColorState.customDarkColor,
                customColorState.customLightColor
            );
            
            // Substitui temporariamente GRASS_COLORS
            const originalColors = [...GRASS_COLORS];
            GRASS_COLORS.length = 0;
            GRASS_COLORS.push(...newPalette);
            
            // Recria as texturas
            grassTextures = createGrassTextures(config.gridSize);
            
            // Atualiza todos os sprites de grama existentes
            for (let x = 0; x < state.cols; x++) {
                for (let y = 0; y < state.rows; y++) {
                    const cell = state.grass[x][y];
                    if (cell && cell.active && cell.sprite) {
                        cell.sprite.texture = grassTextures[cell.colorIndex];
                    }
                }
            }
        }

        // ============================================================
        // NOVO C√ìDIGO - Sistema de Presets (Importar/Exportar)
        // ============================================================

        // Fun√ß√£o para criar objeto de preset com todas as configura√ß√µes
        function createPresetObject() {
            return {
                version: '1.0',
                config: {...config},
                customColors: {
                    isAutoSeasonEnabled: customColorState.isAutoSeasonEnabled,
                    currentSeason: customColorState.currentSeason,
                    customLightColor: customColorState.customLightColor,
                    customDarkColor: customColorState.customDarkColor,
                    isUsingCustomColors: customColorState.isUsingCustomColors
                }
            };
        }

        // Fun√ß√£o para aplicar preset a partir de objeto
        function applyPresetObject(presetObj) {
            // Aplica configura√ß√µes gerais
            if (presetObj.config) {
                Object.assign(config, presetObj.config);
            }
            
            // Aplica cores customizadas se existirem
            if (presetObj.customColors) {
                Object.assign(customColorState, presetObj.customColors);
                
                // Atualiza UI
                document.getElementById('lightGrassColor').value = customColorState.customLightColor;
                document.getElementById('darkGrassColor').value = customColorState.customDarkColor;
                document.getElementById('autoSeasonToggle').checked = customColorState.isAutoSeasonEnabled;
                
                if (customColorState.currentSeason && SEASON_PRESETS[customColorState.currentSeason]) {
                    document.getElementById('seasonName').textContent = SEASON_PRESETS[customColorState.currentSeason].name;
                } else if (customColorState.isUsingCustomColors) {
                    document.getElementById('seasonName').textContent = 'Customizado';
                } else {
                    document.getElementById('seasonName').textContent = '-';
                }
            }
            
            // Atualiza todos os controles da UI
            updateAllUIControls();
            
            // Regenera o jardim
            if (customColorState.isUsingCustomColors) {
                regenerateGrassWithCustomColors();
            } else {
                initializeGarden();
            }
        }

        // Fun√ß√£o para atualizar todos os controles da UI
        function updateAllUIControls() {
            const inputs = document.querySelectorAll('input[type="range"]');
            inputs[0].value = config.clockSize;
            inputs[1].value = config.clockWeight;
            inputs[2].value = config.clockX;
            inputs[3].value = config.clockY;
            inputs[4].value = config.clockAlpha;
            inputs[5].value = config.chunkSize;
            inputs[6].value = config.chunksPerFrame;
            inputs[7].value = config.gridSize;
            inputs[8].value = config.density;
            inputs[9].value = config.height;
            inputs[10].value = config.rainIntensity;
            inputs[11].value = config.dropSize;
            inputs[12].value = config.rainSpeed;
            inputs[13].value = config.windForce;
            inputs[14].value = config.impactForce;
            inputs[15].value = config.splashAmount;
            inputs[16].value = config.speed;
            inputs[17].value = config.particles;
            inputs[18].value = config.maxFireflies;
            
            document.getElementById('val_clockSize').textContent = config.clockSize + 'px';
            document.getElementById('val_clockWeight').textContent = config.clockWeight;
            document.getElementById('val_clockX').textContent = config.clockX + 'px';
            document.getElementById('val_clockY').textContent = config.clockY + 'px';
            document.getElementById('val_clockAlpha').textContent = config.clockAlpha.toFixed(2);
            document.getElementById('val_chunkSize').textContent = config.chunkSize + 'x' + config.chunkSize;
            document.getElementById('val_chunksPerFrame').textContent = config.chunksPerFrame;
            document.getElementById('val_gridSize').textContent = config.gridSize + 'px';
            document.getElementById('val_density').textContent = config.density + '%';
            document.getElementById('val_height').textContent = config.height.toFixed(1) + 'x';
            document.getElementById('val_rainIntensity').textContent = config.rainIntensity;
            document.getElementById('val_dropSize').textContent = config.dropSize.toFixed(1) + 'x';
            document.getElementById('val_rainSpeed').textContent = config.rainSpeed.toFixed(1) + 'x';
            document.getElementById('val_windForce').textContent = config.windForce.toFixed(1);
            document.getElementById('val_impactForce').textContent = config.impactForce.toFixed(1) + 'x';
            document.getElementById('val_splashAmount').textContent = config.splashAmount;
            document.getElementById('val_speed').textContent = config.speed.toFixed(1) + 'x';
            document.getElementById('val_particles').textContent = config.particles;
            document.getElementById('val_maxFireflies').textContent = config.maxFireflies;
            
            updateClockStyle();
        }

        // Fun√ß√£o para salvar preset no localStorage
        function savePresetToLocalStorage() {
            try {
                const preset = createPresetObject();
                localStorage.setItem('jardimPixelPreset', JSON.stringify(preset));
            } catch (e) {
                console.error('Erro ao salvar preset no localStorage:', e);
            }
        }

        // Fun√ß√£o para carregar preset do localStorage
        function loadPresetFromLocalStorage() {
            try {
                const savedPreset = localStorage.getItem('jardimPixelPreset');
                if (savedPreset) {
                    const presetObj = JSON.parse(savedPreset);
                    applyPresetObject(presetObj);
                    return true;
                }
            } catch (e) {
                console.error('Erro ao carregar preset do localStorage:', e);
            }
            return false;
        }

        // Fun√ß√£o para exportar preset como arquivo
        function exportPreset() {
            const preset = createPresetObject();
            const dataStr = JSON.stringify(preset, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'jardim-pixel-preset.json';
            link.click();
            
            URL.revokeObjectURL(url);
        }

        // Fun√ß√£o para importar preset de arquivo
        function importPreset(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const presetObj = JSON.parse(e.target.result);
                    applyPresetObject(presetObj);
                    savePresetToLocalStorage();
                    alert('Preset importado com sucesso!');
                } catch (error) {
                    alert('Erro ao importar preset. Verifique se o arquivo √© v√°lido.');
                    console.error('Erro ao importar preset:', error);
                }
            };
            reader.readAsText(file);
            
            // Limpa o input para permitir reimportar o mesmo arquivo
            event.target.value = '';
        }

        // ============================================================
        // FIM DO NOVO C√ìDIGO
        // ============================================================

        
        const sinCache = new Float32Array(360);
        const cosCache = new Float32Array(360);
        
        for (let i = 0; i < 360; i++) {
            const radians = (i * Math.PI) / 180;
            sinCache[i] = Math.sin(radians);
            cosCache[i] = Math.cos(radians);
        }
        
        function fastSin(angle) {
            const normalized = ((angle % (Math.PI * 2)) / (Math.PI * 2)) * 360;
            return sinCache[Math.floor(normalized) % 360];
        }
        
        function fastCos(angle) {
            const normalized = ((angle % (Math.PI * 2)) / (Math.PI * 2)) * 360;
            return cosCache[Math.floor(normalized) % 360];
        }
        
        function rgbToHex(r, g, b) {
            return (r << 16) | (g << 8) | b;
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 212, g: 244, b: 221 };
        }
        
        let grassTextures = [];
        let raindropTexture = null;
        let fireflyTexture = null;
        let splashTexture = null;
        let backgroundParticles = null;
        let clockText = null;
        
        function createGrassTextures(gridSize) {
            const textures = [];
            const maxHeight = 64;
            
            for (let colorIdx = 0; colorIdx < GRASS_COLORS.length; colorIdx++) {
                const canvas = document.createElement('canvas');
                canvas.width = gridSize;
                canvas.height = maxHeight;
                const ctx = canvas.getContext('2d');
                
                for (let h = 0; h < maxHeight; h++) {
                    const progress = h / maxHeight;
                    const blendedColorIdx = Math.min(
                        Math.floor(progress * GRASS_COLORS.length),
                        GRASS_COLORS.length - 1
                    );
                    
                    const [r, g, b] = GRASS_COLORS[blendedColorIdx];
                    ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                    ctx.fillRect(0, maxHeight - h - 1, gridSize, 1);
                }
                
                textures.push(PIXI.Texture.from(canvas));
            }
            
            return textures;
        }
        
        function createRaindropTexture(width, height) {
            const graphics = new PIXI.Graphics();
            graphics.beginFill(0x96c8ff);
            graphics.drawRect(0, 0, width, height);
            graphics.endFill();
            return app.renderer.generateTexture(graphics);
        }
        
        function createFireflyTexture(size) {
            const graphics = new PIXI.Graphics();
            graphics.beginFill(0x66ccff);
            graphics.drawRect(0, 0, size, size);
            graphics.endFill();
            return app.renderer.generateTexture(graphics);
        }
        
        function createSplashTexture(size) {
            const graphics = new PIXI.Graphics();
            graphics.beginFill(0x96c8ff);
            graphics.drawRect(0, 0, size, size);
            graphics.endFill();
            return app.renderer.generateTexture(graphics);
        }
        
        function createBackgroundParticles() {
            const graphics = new PIXI.Graphics();
            graphics.beginFill(0x3c281e, 0.15);
            for (let i = 0; i < config.particles; i++) {
                const x = (Math.random() * app.screen.width) | 0;
                const y = (Math.random() * app.screen.height) | 0;
                graphics.drawRect(x, y, 2, 2);
            }
            graphics.endFill();
            return graphics;
        }

        function createClock() {
            clockText = new PIXI.Text('', {
                fontFamily: 'sans-serif',
                fontSize: config.clockSize,
                fontWeight: config.clockWeight,
                fill: config.clockColor,
                align: 'right'
            });
            clockText.anchor.set(1, 1);
            clockText.alpha = config.clockAlpha;
            clockContainer.addChild(clockText);
            updateClockPosition();
        }

        function updateClockPosition() {
            if (clockText) {
                clockText.x = app.screen.width + config.clockX;
                clockText.y = app.screen.height + config.clockY;
            }
        }

        function updateClockStyle() {
            if (clockText) {
                clockText.style.fontSize = config.clockSize;
                clockText.style.fontWeight = config.clockWeight;
                clockText.style.fill = config.clockColor;
                clockText.alpha = config.clockAlpha;
                updateClockPosition();
            }
        }

        function updateClock() {
            if (!clockText) return;
            
            const now = new Date();
            const currentMinute = now.getHours() * 60 + now.getMinutes();
            
            if (currentMinute !== state.currentMinute) {
                state.currentMinute = currentMinute;
                const hours = String(now.getHours()).padStart(2, '0');
                const minutes = String(now.getMinutes()).padStart(2, '0');
                clockText.text = `${hours}:${minutes}`;
            }
            
            const floatOffset = Math.sin(state.time * 0.3) * 3;
            clockText.y = app.screen.height + config.clockY + floatOffset;
        }
        
        class Chunk {
            constructor(x, y, size) {
                this.x = x;
                this.y = y;
                this.size = size;
                this.startCol = x * size;
                this.startRow = y * size;
                this.endCol = Math.min(this.startCol + size, state.cols);
                this.endRow = Math.min(this.startRow + size, state.rows);
            }
        }
        
        function initializeChunks() {
            state.chunkCols = Math.ceil(state.cols / config.chunkSize);
            state.chunkRows = Math.ceil(state.rows / config.chunkSize);
            state.chunks = [];
            state.currentChunkIndex = 0;
            
            for (let cy = 0; cy < state.chunkRows; cy++) {
                for (let cx = 0; cx < state.chunkCols; cx++) {
                    state.chunks.push(new Chunk(cx, cy, config.chunkSize));
                }
            }
        }
        
        function initializeGarden() {
            state.cols = Math.floor(app.screen.width / config.gridSize);
            state.rows = Math.floor(app.screen.height / config.gridSize);
            state.grass = new Array(state.cols);
            
            grassContainer.removeChildren();
            flowerContainer.removeChildren();
            fireflyContainer.removeChildren();
            rainContainer.removeChildren();
            splashContainer.removeChildren();
            backgroundContainer.removeChildren();
            clockContainer.removeChildren();
            
            grassTextures = createGrassTextures(config.gridSize);
            raindropTexture = createRaindropTexture(2, 10);
            fireflyTexture = createFireflyTexture(3);
            splashTexture = createSplashTexture(2);
            
            if (config.particles > 0) {
                backgroundParticles = createBackgroundParticles();
                backgroundContainer.addChild(backgroundParticles);
            }

            createClock();
            
            let activeCount = 0;
            for (let x = 0; x < state.cols; x++) {
                state.grass[x] = new Array(state.rows);
                for (let y = 0; y < state.rows; y++) {
                    const isActive = Math.random() * 100 < config.density;
                    
                    const cell = {
                        height: isActive ? Math.random() * 3 : 0,
                        maxHeight: isActive ? (8 + Math.random() * 12) * config.height : 0,
                        growthRate: 0.02 + Math.random() * 0.03,
                        colorIndex: Math.floor(Math.random() * GRASS_COLORS.length),
                        offset: Math.random() * Math.PI * 2,
                        swaySpeed: 0.02 + Math.random() * 0.03,
                        sway: 0,
                        swayDecay: 0.92 + Math.random() * 0.06,
                        active: isActive,
                        wetness: 0,
                        impactSway: 0,
                        impactDecay: 0.85,
                        sprite: null
                    };
                    
                    if (isActive) {
                        const sprite = new PIXI.Sprite(grassTextures[cell.colorIndex]);
                        sprite.anchor.set(0.5, 1);
                        sprite.x = x * config.gridSize + config.gridSize / 2;
                        sprite.y = y * config.gridSize;
                        sprite.height = 0;
                        grassContainer.addChild(sprite);
                        cell.sprite = sprite;
                        activeCount++;
                    }
                    
                    state.grass[x][y] = cell;
                }
            }
            
            state.flowers = [];
            state.fireflies = [];
            state.raindrops = [];
            state.splashes = [];
            state.impacts = [];
            
            initializeChunks();
        }
        
        function getFirefly() {
            if (state.fireflyPool.length > 0) {
                return state.fireflyPool.pop();
            }
            return {
                x: 0, y: 0, vx: 0, vy: 0,
                size: 0, alpha: 0, pulseSpeed: 0, life: 0,
                trail: [],
                sprite: new PIXI.Sprite(fireflyTexture)
            };
        }
        
        function releaseFirefly(firefly) {
            if (firefly.sprite) {
                firefly.sprite.visible = false;
            }
            if (state.fireflyPool.length < config.maxFireflies) {
                state.fireflyPool.push(firefly);
            }
        }
        
        function getRaindrop() {
            if (state.raindropPool.length > 0) {
                return state.raindropPool.pop();
            }
            return {
                x: 0, y: 0, vx: 0, vy: 0,
                length: 0, width: 0, alpha: 0, hasHit: false,
                sprite: new PIXI.Sprite(raindropTexture)
            };
        }
        
        function releaseRaindrop(drop) {
            if (drop.sprite) {
                drop.sprite.visible = false;
            }
            if (state.raindropPool.length < 1000) {
                state.raindropPool.push(drop);
            }
        }
        
        function getSplash() {
            if (state.splashPool.length > 0) {
                return state.splashPool.pop();
            }
            return {
                x: 0, y: 0, vx: 0, vy: 0,
                size: 0, alpha: 0, life: 0, gravity: 0,
                sprite: new PIXI.Sprite(splashTexture)
            };
        }
        
        function releaseSplash(splash) {
            if (splash.sprite) {
                splash.sprite.visible = false;
            }
            if (state.splashPool.length < 500) {
                state.splashPool.push(splash);
            }
        }
        
        function createFirefly() {
            if (state.fireflies.length >= config.maxFireflies) return;
            
            const angle = Math.random() * Math.PI * 2;
            const speed = 1 + Math.random() * 2;
            const firefly = getFirefly();
            
            firefly.x = state.mouseX + (Math.random() - 0.5) * 20;
            firefly.y = state.mouseY + (Math.random() - 0.5) * 20;
            firefly.vx = Math.cos(angle) * speed;
            firefly.vy = Math.sin(angle) * speed;
            firefly.size = 1 + Math.random() * 2;
            firefly.alpha = 0.7 + Math.random() * 0.3;
            firefly.pulseSpeed = 3 + Math.random() * 4;
            firefly.life = 100 + Math.random() * 50;
            firefly.trail = [];
            
            firefly.sprite.visible = true;
            firefly.sprite.anchor.set(0.5);
            firefly.sprite.scale.set(firefly.size);
            fireflyContainer.addChild(firefly.sprite);
            
            state.fireflies.push(firefly);
        }
        
        function createFlower() {
            if (Math.random() > 0.98 && state.flowers.length < 50) {
                const flower = {
                    x: Math.random() * state.cols,
                    y: Math.random() * state.rows,
                    height: 0,
                    maxHeight: (15 + Math.random() * 10) * config.height,
                    growthRate: 0.05 + Math.random() * 0.05,
                    colorIndex: Math.floor(Math.random() * FLOWER_COLORS.length),
                    petalSize: 2 + Math.random() * 2,
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.02,
                    graphics: new PIXI.Graphics()
                };
                
                flowerContainer.addChild(flower.graphics);
                state.flowers.push(flower);
            }
        }
        
        function createRaindrop() {
            if (!state.isRaining) return;
            
            const baseLength = 8 + Math.random() * 8;
            const drop = getRaindrop();
            
            drop.x = Math.random() * app.screen.width;
            drop.y = -5;
            drop.vx = config.windForce * 0.5;
            drop.vy = (8 + Math.random() * 4) * config.rainSpeed;
            drop.length = baseLength * config.dropSize;
            drop.width = Math.max(1, config.dropSize);
            drop.alpha = 0.3 + Math.random() * 0.3;
            drop.hasHit = false;
            
            drop.sprite.visible = true;
            drop.sprite.anchor.set(0.5, 1);
            drop.sprite.alpha = drop.alpha;
            drop.sprite.scale.set(drop.width, drop.length);
            rainContainer.addChild(drop.sprite);
            
            state.raindrops.push(drop);
        }
        
        function createSplash(x, y) {
            const numParticles = Math.floor(config.splashAmount);
            
            for (let i = 0; i < numParticles; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 2 + Math.random() * 4;
                const splash = getSplash();
                
                splash.x = x;
                splash.y = y;
                splash.vx = Math.cos(angle) * speed;
                splash.vy = Math.sin(angle) * speed - 2;
                splash.size = 1 + Math.random() * 2;
                splash.alpha = 0.6 + Math.random() * 0.4;
                splash.life = 20 + Math.random() * 10;
                splash.gravity = 0.3;
                
                splash.sprite.visible = true;
                splash.sprite.anchor.set(0.5);
                splash.sprite.scale.set(splash.size);
                splash.sprite.alpha = splash.alpha;
                splashContainer.addChild(splash.sprite);
                
                state.splashes.push(splash);
            }
        }
        
        function createImpact(gridX, gridY, force) {
            state.impacts.push({
                gridX: gridX,
                gridY: gridY,
                radius: 3,
                force: force * config.impactForce,
                life: 15,
                maxLife: 15
            });
        }

        
        function updateChunk(chunk) {
            const mouseGridX = Math.floor(state.mouseX / config.gridSize);
            const mouseGridY = Math.floor(state.mouseY / config.gridSize);
            const interactionRadius = 5;
            const radiusSquared = interactionRadius * interactionRadius;
            
            for (let x = chunk.startCol; x < chunk.endCol; x++) {
                for (let y = chunk.startRow; y < chunk.endRow; y++) {
                    const cell = state.grass[x][y];
                    if (!cell.active) continue;
                    
                    if (state.isGrowing && cell.height < cell.maxHeight) {
                        cell.height += cell.growthRate * config.speed;
                    }
                    
                    if (cell.sway > 0.1) {
                        cell.sway *= cell.swayDecay;
                    } else {
                        cell.sway = 0;
                    }
                    
                    if (cell.impactSway > 0.1) {
                        cell.impactSway *= cell.impactDecay;
                    } else {
                        cell.impactSway = 0;
                    }
                    
                    const dx = x - mouseGridX;
                    const dy = y - mouseGridY;
                    const distanceSquared = dx * dx + dy * dy;
                    
                    if (distanceSquared <= radiusSquared) {
                        const distance = Math.sqrt(distanceSquared);
                        const influence = (1 - distance / interactionRadius) * 8;
                        cell.sway = Math.max(cell.sway, influence * 0.7);
                    }
                    
                    if (cell.wetness > 0) {
                        cell.wetness = Math.max(0, cell.wetness - 0.01 * config.speed);
                    }
                }
            }
        }
        
        function updateGrassChunked() {
            for (let i = 0; i < config.chunksPerFrame; i++) {
                const chunk = state.chunks[state.currentChunkIndex];
                updateChunk(chunk);
                state.currentChunkIndex = (state.currentChunkIndex + 1) % state.chunks.length;
            }
            
            for (const impact of state.impacts) {
                const centerX = impact.gridX;
                const centerY = impact.gridY;
                const radius = impact.radius;
                const radiusSquared = radius * radius;
                
                for (let x = Math.max(0, centerX - radius); x < Math.min(state.cols, centerX + radius + 1); x++) {
                    for (let y = Math.max(0, centerY - radius); y < Math.min(state.rows, centerY + radius + 1); y++) {
                        const cell = state.grass[x][y];
                        if (!cell.active) continue;
                        
                        const dx = x - centerX;
                        const dy = y - centerY;
                        const distanceSquared = dx * dx + dy * dy;
                        
                        if (distanceSquared <= radiusSquared) {
                            const distance = Math.sqrt(distanceSquared);
                            const influence = (1 - distance / radius) * impact.force;
                            
                            const angle = Math.atan2(dy, dx);
                            cell.impactSway += influence * Math.cos(angle) * 2;
                            cell.wetness = Math.min(1, cell.wetness + 0.3);
                        }
                    }
                }
            }
        }
        
        function updateFlowers() {
            if (state.isGrowing) createFlower();
            
            for (const flower of state.flowers) {
                if (state.isGrowing && flower.height < flower.maxHeight) {
                    flower.height += flower.growthRate * config.speed;
                }
                
                if (flower.height >= flower.maxHeight * 0.8) {
                    flower.rotation += flower.rotationSpeed;
                }
            }
        }
        
        function updateFireflies() {
            if (state.isMouseDown && Math.random() > 0.7) {
                createFirefly();
                createFirefly();
            }
            
            for (let i = state.fireflies.length - 1; i >= 0; i--) {
                const firefly = state.fireflies[i];
                
                firefly.x += firefly.vx * config.speed;
                firefly.y += firefly.vy * config.speed;
                firefly.life -= config.speed;
                
                firefly.trail.push({ x: firefly.x, y: firefly.y });
                if (firefly.trail.length > 10) firefly.trail.shift();
                
                const isOutOfBounds = firefly.x < -10 || firefly.x > app.screen.width + 10 ||
                                     firefly.y < -10 || firefly.y > app.screen.height + 10;
                
                if (firefly.life <= 0 || isOutOfBounds) {
                    releaseFirefly(firefly);
                    state.fireflies.splice(i, 1);
                }
            }
        }
        
        function updateRain() {
            if (state.isRaining && Math.random() * 100 < config.rainIntensity) {
                createRaindrop();
            }
            
            for (let i = state.raindrops.length - 1; i >= 0; i--) {
                const drop = state.raindrops[i];
                
                drop.x += drop.vx * config.speed;
                drop.y += drop.vy * config.speed;
                
                const gridX = Math.floor(drop.x / config.gridSize);
                const gridY = Math.floor(drop.y / config.gridSize);
                
                let shouldRemove = false;
                
                if (gridX >= 0 && gridX < state.cols && gridY >= 0 && gridY < state.rows) {
                    const cell = state.grass[gridX][gridY];
                    
                    if (cell && cell.active && cell.height > 0) {
                        const grassTopY = gridY * config.gridSize - cell.height;
                        
                        if (drop.y >= grassTopY && !drop.hasHit) {
                            drop.hasHit = true;
                            createSplash(drop.x, grassTopY);
                            createImpact(gridX, gridY, 3);
                            shouldRemove = true;
                        }
                    }
                }
                
                if (drop.y >= app.screen.height - 5) {
                    if (!drop.hasHit) {
                        createSplash(drop.x, app.screen.height - 5);
                        if (gridX >= 0 && gridX < state.cols) {
                            createImpact(gridX, state.rows - 1, 2);
                        }
                    }
                    shouldRemove = true;
                }
                
                if (drop.x < -20 || drop.x > app.screen.width + 20) {
                    shouldRemove = true;
                }
                
                if (shouldRemove) {
                    releaseRaindrop(drop);
                    state.raindrops.splice(i, 1);
                }
            }
        }
        
        function updateSplashes() {
            for (let i = state.splashes.length - 1; i >= 0; i--) {
                const splash = state.splashes[i];
                
                splash.x += splash.vx * config.speed;
                splash.y += splash.vy * config.speed;
                splash.vy += splash.gravity * config.speed;
                splash.life -= config.speed;
                
                if (splash.life <= 0 || splash.y > app.screen.height) {
                    releaseSplash(splash);
                    state.splashes.splice(i, 1);
                }
            }
        }
        
        function updateImpacts() {
            for (let i = state.impacts.length - 1; i >= 0; i--) {
                const impact = state.impacts[i];
                impact.life -= config.speed;
                
                if (impact.life <= 0) {
                    state.impacts.splice(i, 1);
                }
            }
        }
        
        function renderGrass() {
            let activeCount = 0;
            const mouseGridX = Math.floor(state.mouseX / config.gridSize);
            const mouseGridY = Math.floor(state.mouseY / config.gridSize);
            
            for (let x = 0; x < state.cols; x++) {
                for (let y = 0; y < state.rows; y++) {
                    const cell = state.grass[x][y];
                    if (!cell.active || !cell.sprite) continue;
                    
                    if (cell.height <= 0) {
                        cell.sprite.visible = false;
                        continue;
                    }
                    
                    cell.sprite.visible = true;
                    activeCount++;
                    
                    const baseSway = fastSin(state.time * cell.swaySpeed + cell.offset) * 2;
                    const totalSway = baseSway + cell.sway + cell.impactSway;
                    const isNearMouse = Math.abs(x - mouseGridX) <= 2 && Math.abs(y - mouseGridY) <= 2;
                    
                    cell.sprite.height = cell.height;
                    cell.sprite.rotation = (totalSway / cell.height) * 0.3;
                    
                    if (isNearMouse && cell.height > cell.maxHeight * 0.7) {
                        cell.sprite.tint = 0xbbffbb;
                    } else if (cell.wetness > 0) {
                        const wetFactor = cell.wetness;
                        const r = Math.floor(GRASS_COLORS[cell.colorIndex][0] * (1 - wetFactor * 0.3));
                        const g = Math.floor(GRASS_COLORS[cell.colorIndex][1] * (1 - wetFactor * 0.3) + 20 * wetFactor);
                        const b = Math.floor(GRASS_COLORS[cell.colorIndex][2] * (1 - wetFactor * 0.3) + 40 * wetFactor);
                        cell.sprite.tint = rgbToHex(r, g, b);
                    } else {
                        cell.sprite.tint = 0xffffff;
                    }
                }
            }
            
            return activeCount;
        }
        
        function renderFlowers() {
            for (const flower of state.flowers) {
                flower.graphics.clear();
                
                if (flower.height <= 5) continue;
                
                const baseX = (flower.x * config.gridSize) | 0;
                const baseY = (flower.y * config.gridSize) | 0;
                const stemHeight = flower.height | 0;
                
                flower.graphics.beginFill(0x2d5a3d);
                flower.graphics.drawRect(baseX, baseY - stemHeight, 2, stemHeight);
                flower.graphics.endFill();
                
                if (flower.height >= flower.maxHeight * 0.8) {
                    const flowerTop = baseY - stemHeight;
                    const [r, g, b] = FLOWER_COLORS[flower.colorIndex];
                    
                    for (let p = 0; p < 8; p++) {
                        const angle = (Math.PI * 0.25 * p) + flower.rotation;
                        const petalX = baseX + fastCos(angle) * flower.petalSize * 2;
                        const petalY = flowerTop + fastSin(angle) * flower.petalSize * 2;
                        
                        flower.graphics.beginFill(rgbToHex(r, g, b));
                        flower.graphics.drawRect(
                            petalX | 0, 
                            petalY | 0, 
                            Math.ceil(flower.petalSize), 
                            Math.ceil(flower.petalSize)
                        );
                        flower.graphics.endFill();
                    }
                    
                    flower.graphics.beginFill(0xffdd44);
                    flower.graphics.drawRect(baseX - 1, flowerTop - 1, 3, 3);
                    flower.graphics.endFill();
                }
            }
        }
        
        function renderFireflies() {
            for (const firefly of state.fireflies) {
                const pulse = fastSin(state.time * firefly.pulseSpeed) * 0.3 + 0.7;
                
                firefly.sprite.x = firefly.x;
                firefly.sprite.y = firefly.y;
                firefly.sprite.alpha = firefly.alpha * pulse;
            }
        }
        
        function renderRain() {
            for (const drop of state.raindrops) {
                drop.sprite.x = drop.x;
                drop.sprite.y = drop.y;
                
                const angle = Math.atan2(drop.vy, drop.vx);
                drop.sprite.rotation = angle + Math.PI / 2;
            }
        }
        
        function renderSplashes() {
            for (const splash of state.splashes) {
                splash.sprite.x = splash.x;
                splash.sprite.y = splash.y;
                
                const fadeAlpha = (splash.life / 30) * splash.alpha;
                splash.sprite.alpha = fadeAlpha;
            }
        }

        
        app.ticker.add(() => {
            const now = performance.now();
            const delta = now - state.lastTime;
            state.lastTime = now;
            
            state.frames++;
            state.fpsTime += delta;
            
            if (state.fpsTime >= 1000) {
                state.fps = (state.frames * 1000 / state.fpsTime) | 0;
                document.getElementById('stat_fps').textContent = state.fps;
                state.frames = 0;
                state.fpsTime = 0;
            }
            
            state.time += 0.016 * config.speed;
            
            updateGrassChunked();
            updateFlowers();
            updateFireflies();
            updateRain();
            updateSplashes();
            updateImpacts();
            updateClock();
            
            const grassCount = renderGrass();
            renderFlowers();
            renderFireflies();
            renderRain();
            renderSplashes();
            
            document.getElementById('stat_grass').textContent = grassCount;
            document.getElementById('stat_flowers').textContent = state.flowers.length;
            document.getElementById('stat_fireflies').textContent = state.fireflies.length;
            document.getElementById('stat_rain').textContent = state.raindrops.length;
            document.getElementById('stat_splashes').textContent = state.splashes.length;
            document.getElementById('stat_chunks').textContent = state.chunks.length;
        });
        
        function togglePanel() {
            document.getElementById('panel').classList.toggle('open');
        }
        
        function togglePause() {
            state.isGrowing = !state.isGrowing;
            const btn = document.getElementById('pauseBtn');
            btn.textContent = state.isGrowing ? '‚è∏ Pausar' : '‚ñ∂ Continuar';
        }
        
        function toggleRain() {
            state.isRaining = !state.isRaining;
            const btn = document.getElementById('rainBtn');
            btn.textContent = state.isRaining ? 'üåßÔ∏è Parar' : 'üåßÔ∏è Chuva';
            btn.classList.toggle('active', state.isRaining);
        }
        
        function resetGarden() {
            initializeGarden();
        }
        
        function updateConfig(key, value) {
            const valueNum = parseFloat(value);
            
            const configMap = {
                clockSize: () => {
                    config.clockSize = valueNum;
                    document.getElementById('val_clockSize').textContent = valueNum + 'px';
                    updateClockStyle();
                },
                clockWeight: () => {
                    config.clockWeight = valueNum;
                    document.getElementById('val_clockWeight').textContent = valueNum;
                    updateClockStyle();
                },
                clockX: () => {
                    config.clockX = valueNum;
                    document.getElementById('val_clockX').textContent = valueNum + 'px';
                    updateClockPosition();
                },
                clockY: () => {
                    config.clockY = valueNum;
                    document.getElementById('val_clockY').textContent = valueNum + 'px';
                    updateClockPosition();
                },
                clockColor: () => {
                    config.clockColor = value;
                    updateClockStyle();
                },
                clockAlpha: () => {
                    config.clockAlpha = valueNum;
                    document.getElementById('val_clockAlpha').textContent = valueNum.toFixed(2);
                    updateClockStyle();
                },
                chunkSize: () => {
                    config.chunkSize = valueNum;
                    document.getElementById('val_chunkSize').textContent = valueNum + 'x' + valueNum;
                    initializeChunks();
                },
                chunksPerFrame: () => {
                    config.chunksPerFrame = valueNum;
                    document.getElementById('val_chunksPerFrame').textContent = valueNum;
                },
                gridSize: () => {
                    config.gridSize = valueNum;
                    document.getElementById('val_gridSize').textContent = valueNum + 'px';
                    initializeGarden();
                },
                density: () => {
                    config.density = valueNum;
                    document.getElementById('val_density').textContent = valueNum + '%';
                    initializeGarden();
                },
                height: () => {
                    config.height = valueNum;
                    document.getElementById('val_height').textContent = valueNum.toFixed(1) + 'x';
                    initializeGarden();
                },
                speed: () => {
                    config.speed = valueNum;
                    document.getElementById('val_speed').textContent = valueNum.toFixed(1) + 'x';
                },
                particles: () => {
                    config.particles = valueNum;
                    document.getElementById('val_particles').textContent = valueNum;
                    backgroundContainer.removeChildren();
                    if (valueNum > 0) {
                        backgroundParticles = createBackgroundParticles();
                        backgroundContainer.addChild(backgroundParticles);
                    }
                },
                maxFireflies: () => {
                    config.maxFireflies = valueNum;
                    document.getElementById('val_maxFireflies').textContent = valueNum;
                },
                rainIntensity: () => {
                    config.rainIntensity = valueNum;
                    document.getElementById('val_rainIntensity').textContent = valueNum;
                },
                dropSize: () => {
                    config.dropSize = valueNum;
                    document.getElementById('val_dropSize').textContent = valueNum.toFixed(1) + 'x';
                },
                rainSpeed: () => {
                    config.rainSpeed = valueNum;
                    document.getElementById('val_rainSpeed').textContent = valueNum.toFixed(1) + 'x';
                },
                windForce: () => {
                    config.windForce = valueNum;
                    document.getElementById('val_windForce').textContent = valueNum.toFixed(1);
                },
                impactForce: () => {
                    config.impactForce = valueNum;
                    document.getElementById('val_impactForce').textContent = valueNum.toFixed(1) + 'x';
                },
                splashAmount: () => {
                    config.splashAmount = valueNum;
                    document.getElementById('val_splashAmount').textContent = valueNum;
                }
            };
            
            if (configMap[key]) {
                configMap[key]();
            }
            
            // NOVO: Salva automaticamente ap√≥s cada mudan√ßa de configura√ß√£o
            savePresetToLocalStorage();
        }
        
        function applyPreset(presetName) {
            const presets = {
                low: {
                    chunkSize: 32,
                    chunksPerFrame: 2,
                    gridSize: 6,
                    density: 50,
                    height: 0.8,
                    particles: 30,
                    maxFireflies: 100,
                    rainIntensity: 30,
                    dropSize: 0.8,
                    rainSpeed: 0.8,
                    windForce: 0,
                    impactForce: 0.7,
                    splashAmount: 3
                },
                medium: {
                    chunkSize: 16,
                    chunksPerFrame: 4,
                    gridSize: 4,
                    density: 75,
                    height: 1,
                    particles: 100,
                    maxFireflies: 200,
                    rainIntensity: 50,
                    dropSize: 1,
                    rainSpeed: 1,
                    windForce: 0,
                    impactForce: 1,
                    splashAmount: 5
                },
                high: {
                    chunkSize: 12,
                    chunksPerFrame: 6,
                    gridSize: 3,
                    density: 100,
                    height: 1.2,
                    particles: 150,
                    maxFireflies: 300,
                    rainIntensity: 70,
                    dropSize: 1.3,
                    rainSpeed: 1.2,
                    windForce: 1,
                    impactForce: 1.5,
                    splashAmount: 7
                },
                ultra: {
                    chunkSize: 8,
                    chunksPerFrame: 8,
                    gridSize: 2,
                    density: 100,
                    height: 1.5,
                    particles: 200,
                    maxFireflies: 400,
                    rainIntensity: 90,
                    dropSize: 1.5,
                    rainSpeed: 1.5,
                    windForce: 2,
                    impactForce: 2,
                    splashAmount: 10
                },
                retro: {
                    chunkSize: 32,
                    chunksPerFrame: 2,
                    gridSize: 8,
                    density: 60,
                    height: 0.6,
                    particles: 50,
                    maxFireflies: 50,
                    rainIntensity: 20,
                    dropSize: 0.5,
                    rainSpeed: 0.6,
                    windForce: 0,
                    impactForce: 0.5,
                    splashAmount: 2
                },
                storm: {
                    chunkSize: 16,
                    chunksPerFrame: 6,
                    gridSize: 3,
                    density: 100,
                    height: 1,
                    particles: 80,
                    maxFireflies: 150,
                    rainIntensity: 100,
                    dropSize: 2,
                    rainSpeed: 2,
                    windForce: 4,
                    impactForce: 2.5,
                    splashAmount: 10
                }
            };
            
            const preset = presets[presetName];
            if (!preset) return;
            
            Object.assign(config, preset);
            
            const inputs = document.querySelectorAll('input[type="range"]');
            inputs[0].value = config.clockSize;
            inputs[1].value = config.clockWeight;
            inputs[2].value = config.clockX;
            inputs[3].value = config.clockY;
            inputs[4].value = config.clockAlpha;
            inputs[5].value = config.chunkSize;
            inputs[6].value = config.chunksPerFrame;
            inputs[7].value = config.gridSize;
            inputs[8].value = config.density;
            inputs[9].value = config.height;
            inputs[10].value = config.rainIntensity;
            inputs[11].value = config.dropSize;
            inputs[12].value = config.rainSpeed;
            inputs[13].value = config.windForce;
            inputs[14].value = config.impactForce;
            inputs[15].value = config.splashAmount;
            inputs[16].value = config.speed;
            inputs[17].value = config.particles;
            inputs[18].value = config.maxFireflies;
            
            document.getElementById('val_clockSize').textContent = config.clockSize + 'px';
            document.getElementById('val_clockWeight').textContent = config.clockWeight;
            document.getElementById('val_clockX').textContent = config.clockX + 'px';
            document.getElementById('val_clockY').textContent = config.clockY + 'px';
            document.getElementById('val_clockAlpha').textContent = config.clockAlpha.toFixed(2);
            document.getElementById('val_chunkSize').textContent = config.chunkSize + 'x' + config.chunkSize;
            document.getElementById('val_chunksPerFrame').textContent = config.chunksPerFrame;
            document.getElementById('val_gridSize').textContent = config.gridSize + 'px';
            document.getElementById('val_density').textContent = config.density + '%';
            document.getElementById('val_height').textContent = config.height.toFixed(1) + 'x';
            document.getElementById('val_rainIntensity').textContent = config.rainIntensity;
            document.getElementById('val_dropSize').textContent = config.dropSize.toFixed(1) + 'x';
            document.getElementById('val_rainSpeed').textContent = config.rainSpeed.toFixed(1) + 'x';
            document.getElementById('val_windForce').textContent = config.windForce.toFixed(1);
            document.getElementById('val_impactForce').textContent = config.impactForce.toFixed(1) + 'x';
            document.getElementById('val_splashAmount').textContent = config.splashAmount;
            document.getElementById('val_speed').textContent = config.speed.toFixed(1) + 'x';
            document.getElementById('val_particles').textContent = config.particles;
            document.getElementById('val_maxFireflies').textContent = config.maxFireflies;
            
            updateClockStyle();
            initializeGarden();
            
            // NOVO: Salva automaticamente ap√≥s aplicar preset
            savePresetToLocalStorage();
        }
        
        function showUI() {
            state.uiVisible = true;
            const btn = document.querySelector('.config-btn');
            btn.style.opacity = '1';
            btn.style.pointerEvents = 'auto';
        }
        
        function hideUI() {
            const panel = document.getElementById('panel');
            if (panel.classList.contains('open')) return;
            
            state.uiVisible = false;
            const btn = document.querySelector('.config-btn');
            btn.style.opacity = '0';
            btn.style.pointerEvents = 'none';
        }
        
        function checkUITimeout() {
            if (Date.now() - state.lastMouseMove > 5000) {
                hideUI();
            }
        }
        
        function handleMouseMove() {
            state.lastMouseMove = Date.now();
            if (!state.uiVisible) {
                showUI();
            }
        }
        
        app.view.addEventListener('mousemove', (e) => {
            const rect = app.view.getBoundingClientRect();
            state.mouseX = e.clientX - rect.left;
            state.mouseY = e.clientY - rect.top;
        });
        
        app.view.addEventListener('mousedown', () => {
            state.isMouseDown = true;
        });
        
        app.view.addEventListener('mouseup', () => {
            state.isMouseDown = false;
        });
        
        app.view.addEventListener('mouseleave', () => {
            state.mouseX = -100;
            state.mouseY = -100;
            state.isMouseDown = false;
        });
        
        app.view.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const rect = app.view.getBoundingClientRect();
            const touch = e.touches[0];
            state.mouseX = touch.clientX - rect.left;
            state.mouseY = touch.clientY - rect.top;
        }, { passive: false });
        
        app.view.addEventListener('touchstart', () => {
            state.isMouseDown = true;
        });
        
        app.view.addEventListener('touchend', () => {
            state.isMouseDown = false;
        });
        
        document.addEventListener('mousemove', handleMouseMove);
        
        document.addEventListener('keydown', (e) => {
            if (e.key === 'F11' || e.key === 'f') {
                handleMouseMove();
            }
        });

        window.addEventListener('resize', () => {
            updateClockPosition();
        });
        
        setInterval(checkUITimeout, 1000);
        
        // ============================================================
        // NOVO C√ìDIGO - Inicializa√ß√£o com carregamento autom√°tico
        // ============================================================
        
        // Tenta carregar preset salvo ao iniciar
        const presetLoaded = loadPresetFromLocalStorage();
        
        // Se n√£o houver preset salvo, inicializa normalmente
        if (!presetLoaded) {
            initializeGarden();
            
            // Define valores padr√£o para cores customizadas
            document.getElementById('lightGrassColor').value = customColorState.customLightColor;
            document.getElementById('darkGrassColor').value = customColorState.customDarkColor;
            document.getElementById('seasonName').textContent = '-';
        }
        
        // Verifica se deve aplicar modo autom√°tico de esta√ß√£o ao iniciar
        if (customColorState.isAutoSeasonEnabled) {
            const currentSeason = detectCurrentSeason();
            if (currentSeason !== customColorState.currentSeason) {
                applySeasonPreset(currentSeason);
                customColorState.isAutoSeasonEnabled = true;
                document.getElementById('autoSeasonToggle').checked = true;
            }
        }
    </script>
</body>
</html>
